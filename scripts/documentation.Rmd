---
title: "Identifying nests and swallows based on spatiotemporal wild boar data."
subtitle: "Project Works Patterns and Trends in Environmental Data"
author: "Yves Gubelmann and Tobias Wildhaber"
date: "4 July, 2021"
output: 
  bookdown::html_document2:
    toc: true
    toc_float: true
    number_sections: true
    theme: darkly
    highlight: tango
    code_folding: hide
bibliography: references.bib
csl: apa.csl
---

```{r chunk settings, echo = TRUE, warning=FALSE, message=FALSE}

# You can set chunk options individually per code chunk, as was done with this
# code chunk.

# echo = FALSE           hides the code from the generated output
# warning = FALSE        hides warnings from the generated output
# message = FALSE        hides messages from the generated output

# To set the setting for all code chunks, use the following code:

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

```

```{r main, include=FALSE, appendix=TRUE}
# libraries ---------------------------------------------------------------

# install package with wildobar data:
# devtools::install_github("ComputationalMovementAnalysis/ComputationalMovementAnalysisData")

library(tidyverse) # tidy essentials (ggplot, purr, tidyr, readr, dplyr)
library(lubridate) # handling dates and time
library(tmap) # map visualization
library(leaflet) # interactive maps
library(terra) # handling spatial data
library(ComputationalMovementAnalysisData) # wild boar data
library(sf) # handling spatial data
library(janitor) # clean and consistent naming
library(forcats) # handling factor levels
library(raster) # rasterizing vector data

# globals ----------------------------------------------------------------------
# change working directory
# setwd(r"(C:\code_wc\Modul_CMA\patreco-project-work)")

# auskommentiert, da zu Fehlermeldung gefuehrt, stattdessen in Global Options unter # R Markdown "Evaluate junks in directory" auf "Project" umstellen

# threshold that triggers the segmentation of the movement trajectory

segment_trigger <- 40

# functions ---------------------------------------------------------------

calc_movement_param <- function(boar_dt) {
  boar_dt <- boar_dt %>%
    mutate(
      timelag = as.integer(difftime(lead(DatetimeUTC), DatetimeUTC, units = "secs")),
      steplength = sqrt(((E - lead(E, 1))^2 + (N - lead(N, 1))^2)),
      speed = steplength / timelag,
      nMinus3 = sqrt((lag(E, 3) - E)^2 + (lag(N, 3) - N)^2),
      nMinus2 = sqrt((lag(E, 2) - E)^2 + (lag(N, 2) - N)^2),
      nMinus1 = sqrt((lag(E, 1) - E)^2 + (lag(N, 1) - N)^2),
      nPlus1 = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2),
      nPlus2 = sqrt((E - lead(E, 2))^2 + (N - lead(N, 2))^2),
      nPlus3 = sqrt((E - lead(E, 3))^2 + (N - lead(N, 3))^2)
    ) %>%
    rowwise() %>%
    mutate(
      stepmean = mean(c(nMinus3, nMinus2, nMinus1, nPlus1, nPlus2, nPlus3)),
    ) %>%
    ungroup() %>%
    mutate(
      mov_static = if_else(stepmean < segment_trigger, TRUE, FALSE),
      mov_status = if_else(stepmean < segment_trigger, "resting", "moving"),
      cma_static = stepmean < mean(stepmean, na.rm = TRUE)
    )
  boar_dt
}

rle_id <- function(vec) {
  x <- rle(vec)$lengths
  as.factor(rep(seq_along(x), times = x))
}

# data import -------------------------------------------------------------

wildboar_raw <- wildschwein_BE
head(wildboar_raw)

wildboar_meta <- wildschwein_metadata
head(wildboar_meta)
#?wildschwein_metadata

wildboar_overlap <- wildschwein_overlap_temp
head(wildboar_overlap)
#?wildschwein_overlap_temp

# import feldaufnahmen
feldaufnahmen <- read_sf("data/Feldaufnahmen_Fanel.gpkg")

# add geometry and time---------------------------------------------------------

# argument remove = False keeps the coordinates E and N
wildboar_sf <- st_as_sf(wildboar_raw, coords = c("E", "N"), crs = 2056, remove = FALSE)
# join feldaufnahmen with wildboar data
wildboar_sf <- st_join(x = wildboar_sf, y = feldaufnahmen)
# add time
wildboar_sf <- wildboar_sf %>%
  mutate(
    month = month(DatetimeUTC),
    year = year(DatetimeUTC)
  )

# data exploration --------------------------------------------------------

# plotting data points ####
#
# ggplot(wildboar_sf, aes(color = TierName)) +
#   geom_sf(alpha = 0.4) +
#   coord_sf(datum = 2056)
#
# ggplot(wildboar_sf, aes(color = as.factor(TierID))) +
#   geom_sf(alpha = 0.4) +
#   coord_sf(datum = 2056) +
#   scale_color_discrete(name = "AnimalID")

# sampling regime ####
#
# limits <- c(0,200)
# breaks = seq(0,200,50)
# labels = paste(c(rep("",length(breaks)-1),">"), breaks)
#
# sampling_regime <- wildboar_raw %>%
#   mutate(TierName = fct_reorder(TierName, DatetimeUTC,min, .desc = TRUE)) %>%
#   group_by(TierID, TierName, CollarID) %>%
#   mutate(
#     timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC, units = "mins")),
#   ) %>%
#   ggplot(aes(DatetimeUTC, TierName, colour = timelag)) +
#   geom_line(lwd = 10) +
#   scale_color_gradientn(name = "Sampling interval", colours = RColorBrewer::brewer.pal(11, "Spectral"), limits = limits, na.value = NA, oob = scales::squish, breaks = seq(0,200,50), labels = labels) +
#   theme_minimal() +
#   theme(legend.position = "top") +
#   guides(color = guide_colorbar(title.position = "top", title.hjust = .5, barwidth = unit(20, "lines"), barheight = unit(.5, "lines")))

# temporal overlap ####

# ?wildschwein_overlap_temp
#
# sampling_periods <- wildboar_raw %>%
#   group_by(TierID, TierName, CollarID) %>%
#   summarise(
#     min = min(DatetimeUTC),
#     max = max(DatetimeUTC)
#   )
#
# wildboar_overlap <- wildboar_overlap %>%
#   left_join(sampling_periods, by = c("TierID", "TierName", "CollarID"))
#
# wildboar_overlap %>%
#   mutate(TierCollar = paste(TierName, CollarID)) %>%
#   ggplot(aes(xmin = min, xmax = max, y = TierCollar)) +
#   geom_errorbarh() +
#   facet_grid(Groups~., scales = "free_y", space = "free_y")
#
# ggplot(wildboar_sf, aes(x = DatetimeUTC, y = TierName)) +
#   geom_point() +
#   scale_x_datetime(breaks = "1 month") +
#   theme_grey()


# spatial overlap ####

# convex hull ####
#
# wildboar_sf <- wildboar_sf %>%
#   mutate(tiercollar = paste(TierID, TierName, CollarID))
#
# mcp <- wildboar_sf %>%
#   group_by(TierID, TierName, CollarID) %>%
#   summarise() %>%
#   st_convex_hull()

# plot convex hull ####
#
# mcp %>%
#   mutate(tiercollar = paste(TierID, TierName, CollarID)) %>%
#   ggplot(aes(fill = factor(TierID))) + geom_sf(alpha = 0.1) +
#   coord_sf(datum = 2056) +
#   facet_wrap(~tiercollar) +
#   theme(legend.position = "none")
#
#
# tmap_mode("view") +
#   tm_shape(mcp) +
#   tm_fill("TierName", alpha = 0.5) +
#   tm_borders(col = "red", lwd = 1) +
#   tm_layout(legend.bg.color = "white")


# time lags ####

# replace wildboar_raw by wildboar_sf for spatial information
wildboar_lags <- wildboar_sf %>%
  group_by(TierID) %>%
  mutate(timelag = as.integer(difftime(lead(DatetimeUTC), DatetimeUTC), units = "secs"))

# round lags on -2 digits
wildboar_lags$timelag_rounded <- round(wildboar_lags$timelag, -2)

# build categories with rounded lags
wildboar_lag_cat <- wildboar_lags %>%
  st_drop_geometry() %>%
  group_by(timelag_rounded) %>%
  summarise(count = n())
wildboar_lag_cat

#### DELETE ####
# used below
# compares count of timelag_rounded
hist_lag_cat <- ggplot(wildboar_lag_cat)
hist_lag_cat + geom_col(aes(x = timelag_rounded, y = count)) +
  coord_cartesian(ylim=c(0,200000), xlim=c(0,5000)) +
  labs(x = "rounded timelag [seconds]",
     y = "number of counts", 
     title = "Distribution of timelag between to data points",
     subtitle = "a clear majority is sampled with a timelag of 900 seconds") +   theme_bw() +
  theme(panel.border = element_blank())

# viualise change in lag over time ####

# takes a while for plotting..
# wildboar_lags %>%
#   filter(timelag < 30000 & timelag > 0) %>%
#   ggplot(., aes(DatetimeUTC, timelag, col = TierName)) +
#   geom_point() +
#   geom_line(size = 0.1)

# DELETE: calculating steplength ####

# wildboar_lags$steplength <- wildboar_raw %>%
#   {
#     (.$E - lead(.$E))^2 + (.$N - lead(.$N))^2
#   } %>%
#   sqrt()

# calculating speed based on timelag (t) in secs and steplength (s) in meter ####

# wildboar_lags$speed <- wildboar_lags %>% {
#   .$steplength / .$timelag
# }


# sample code for different intervals (to be discussed)
# wildboar_3 <- wildboar_3 %>%
#   mutate(timelag = as.integer(difftime(lead(DatetimeUTC), DatetimeUTC), units = "secs"))
#
# wildboar_3$steplength <- wildboar_3 %>%
#   {
#     (.$E - lead(.$E))^2 + (.$N - lead(.$N))^2
#   } %>%
#   sqrt()
#
# wildboar_3$speed <- wildboar_3 %>% {
#   .$steplength / .$timelag
# }

# preprocessing ####

# assign convenience variables for step 6
wildboar_lags <- wildboar_lags %>%
  # add wallow and nest criterias according to literature
  # enable line below if you want to filter all NAs in Frucht
  # filter(!is.na(Frucht)) %>%
  mutate(
    wallow_month = if_else(month > 3 & month < 10, TRUE, FALSE),
    wallow_day = case_when(
      day == "Abenddaemmerung" ~ FALSE,
      day == "Morgendaemmerung" ~ TRUE,
      day == "Nacht" ~ FALSE,
      day == "1Nachtviertel" ~ FALSE,
      day == "2Nachtviertel" ~ FALSE,
      day == "3Nachtviertel" ~ FALSE,
      day == "4Nachtviertel" ~ FALSE,
      day == "Tag" ~ TRUE,
      TRUE ~ NA # Default case
    ),
    wallow_area = case_when(
      Frucht == "Feuchtgebiet" ~ TRUE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ FALSE,
      Frucht == "Gerste" ~ FALSE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ FALSE,
      Frucht == "Raps" ~ FALSE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ FALSE,
      Frucht == "Roggen" ~ FALSE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    ),
    nest_day = case_when(
      day == "Abenddaemmerung" ~ FALSE,
      day == "Morgendaemmerung" ~ FALSE,
      day == "Nacht" ~ FALSE,
      day == "1Nachtviertel" ~ FALSE,
      day == "2Nachtviertel" ~ FALSE,
      day == "3Nachtviertel" ~ FALSE,
      day == "4Nachtviertel" ~ FALSE,
      day == "Tag" ~ TRUE,
      TRUE ~ NA # Default case
    ),
    nest_summer_mon = if_else(month >= 5 & month <= 10, TRUE, FALSE),
    nest_winter_mon = if_else(month >= 5 & month <= 10, FALSE, TRUE),
    nest_summer_area = case_when(
      Frucht == "Feuchtgebiet" ~ FALSE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ TRUE,
      Frucht == "Gerste" ~ TRUE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ TRUE,
      Frucht == "Raps" ~ TRUE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ TRUE,
      Frucht == "Roggen" ~ TRUE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    ),
    nest_winter_area = case_when(
      Frucht == "Feuchtgebiet" ~ TRUE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ FALSE,
      Frucht == "Gerste" ~ FALSE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ FALSE,
      Frucht == "Raps" ~ FALSE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ FALSE,
      Frucht == "Roggen" ~ FALSE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    )
  )

# This checks a certain variable for NAs
# na_check <- wildboar_lags %>%
#   filter(is.na(wallow_area))

wildboar_lags <- calc_movement_param(wildboar_lags)
wildboar_lags <- wildboar_lags %>%
  # run segment-based analysis with rle_id. copied from cma_week 3
  # choose between: own threshold (mov_static) or from cma_week 3 (cma_static)
  mutate(segment_id = rle_id(mov_static)) %>%
  # select only rows with an certain timelag
  # if no filter is applied, sequencing creates misleading results
  # fraglich, ob der filter hier angewendet werden soll oder nach Sample data
  filter(timelag_rounded == 900)

#### visualize movement status ####

summary(as.factor(wildboar_lags$mov_status))

mov_status <- data.frame(summary(as.factor(wildboar_lags$mov_status))) %>% 
  rename(count = 1) %>% 
  slice(-3) %>% 
  rownames_to_column(var = "status") %>% 
  mutate(prop = count/sum(count) * 100,
         prop = round(prop, 1)) %>% 
  arrange(desc(status)) %>%
  mutate(lab.ypos = cumsum(prop) - 0.5 * prop)

pie <- ggplot(mov_status, aes(x = "", y = prop, fill = status)) +
  geom_bar(width = 1, stat = "identity", color = "white") +
  coord_polar("y", start = 0) +
  geom_text(aes(y = lab.ypos, label = prop), color = "white") +
  scale_fill_discrete(name = "Status", labels = c("Resting", "Moving")) +
  theme_void()

pie

# cross-scale movement analysis ####
seq3 <- seq(from = 1, to = nrow(wildboar_raw), by = 3)
seq6 <- seq(from = 1, to = nrow(wildboar_raw), by = 6)
seq9 <- seq(from = 1, to = nrow(wildboar_raw), by = 9)
# Mein Vorschlag: unsere Auswertung aller Daten basiert auf wildboar_lags
# wildboar_3 <- wildboar_lags %>% slice(seq3)
# wildboar_6 <- wildboar_lags %>% slice(seq6)
# wildboar_9 <- wildboar_lags %>% slice(seq9)

# Sample data -------------------------------------------------------------

# step0 : select three different wildboars for a duration of two weeks ####
# Kritisch: hier werden samples aus wildboar_sf kreiert. so gehen viele
# convenience variablen verloren. Zudem ist es fehleranfälliger. Überdenken.

# create a sample of caroline
caro <- wildboar_sf %>%
  filter(
    year == 2015,
    month == 5,
    TierName == "Caroline"
  )

# create a sample of Frida
frida <- wildboar_sf %>%
  filter(
    year == 2016,
    month == 5,
    TierName == "Frida"
  )

# create a sample of Ueli
ueli <- wildboar_sf %>%
  filter(
    year == 2016,
    month == 5,
    TierName == "Ueli"
  )

# step 1: sequence data ####
# for sample data
caro_seq3 <- seq(from = 1, to = nrow(caro), by = 3)
caro_seq6 <- seq(from = 1, to = nrow(caro), by = 6)
frida_seq3 <- seq(from = 1, to = nrow(frida), by = 3)
frida_seq6 <- seq(from = 1, to = nrow(frida), by = 6)
ueli_seq3 <- seq(from = 1, to = nrow(ueli), by = 3)
ueli_seq6 <- seq(from = 1, to = nrow(ueli), by = 6)
caro_3 <- caro %>% slice(caro_seq3)
caro_6 <- caro %>% slice(caro_seq6)
frida_3 <- frida %>% slice(frida_seq3)
frida_6 <- frida %>% slice(frida_seq6)
ueli_3 <- ueli %>% slice(ueli_seq3)
ueli_6 <- ueli %>% slice(ueli_seq6)


# step 2: calculate speed, steplength and timelag for segmented da ####

# for sample data, for wildboar_lags its already done
caro <- calc_movement_param(caro)
caro_3 <- calc_movement_param(caro_3)
caro_6 <- calc_movement_param(caro_6)
frida <- calc_movement_param(frida)
frida_3 <- calc_movement_param(frida_3)
frida_6 <- calc_movement_param(frida_6)
ueli <- calc_movement_param(ueli)
ueli_3 <- calc_movement_param(ueli_3)
ueli_6 <- calc_movement_param(ueli_6)



# step 3: plot histogram and movement trajectories ------------------------

# plot histogram of stepmean
stepmean_ueli <- ggplot(ueli_6, aes(x = stepmean, fill = mov_status))
stepmean_ueli + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(x = "Mean steplength [meter]",
   y = "Number of counts", 
   title = "Mean steplength of wildboar Ueli",
   subtitle = "Sample dataset from May 2016 (segment_trigger = 40)")

stepmean_caro <- ggplot(caro_6, aes(x = stepmean, fill = mov_status))
stepmean_caro + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(x = "Mean steplength [meter]",
   y = "Number of counts", 
   title = "Mean steplength of wildboar Caroline",
   subtitle = "Sample dataset from May 2015 (segment_trigger = 40)")

stepmean_frida <- ggplot(frida_6, aes(x = stepmean, fill = mov_status))
stepmean_frida + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(x = "Mean steplength [meter]",
   y = "Number of counts", 
   title = "Mean steplength of wildboar Frida",
   subtitle = "Sample dataset from May 2016 (segment_trigger = 40)")


# step 4 to 6: assign movement status and apply criterias -----------------


# for all data

wildboar_lags <- wildboar_lags %>%
  group_by(segment_id) %>%
  mutate(segment_dur = n()) %>%
  filter(row_number(segment_id) == 1) %>% # keep only the first data point per segment
  ungroup() %>%
  mutate(wallow_dur = if_else(segment_dur <= 3, TRUE, FALSE)) %>%
  filter(mov_status == "resting") %>%
  mutate(
    wallow = if_else(wallow_month & wallow_day & wallow_area & wallow_dur,
      TRUE, FALSE
    ),
    nest = if_else((nest_summer_mon & nest_day & nest_summer_area & segment_dur > 3) |
      (nest_winter_mon & nest_day & nest_winter_area & segment_dur > 3),
    TRUE, FALSE
    ),
    conflict = if_else(nest & wallow, TRUE, FALSE),
    site_type = as.factor(case_when(
      conflict == TRUE ~ "both",
      nest == TRUE ~ "nest",
      wallow == TRUE ~ "wallow",
      !wallow & !nest == TRUE ~ "none",
      TRUE ~ "NA" # Default case
    ))
  )
  

# check the dataset (number of wallows, nests, NAs etc)

summary(wildboar_lags)

# create pie chart for site_type ####

site_type <- data.frame(summary(wildboar_lags$site_type)) %>% 
  rename(count = 1) %>% 
  rownames_to_column(var = "type") %>% 
  mutate(prop = count/sum(count) * 100,
         prop = round(prop, 1)) %>% 
  arrange(desc(type)) %>%
  mutate(lab.ypos = cumsum(prop) - 0.5 * prop)

pie <- ggplot(site_type, aes(x = "", y = prop, fill = type)) +
  geom_bar(width = 1, stat = "identity", color = "white") +
  coord_polar("y", start = 0) +
  geom_text(aes(y = lab.ypos, label = prop), color = "white") +
  scale_fill_discrete(name = "Type", labels = c("NA", "Nest", "None", "Wallow")) +
  theme_void()

pie


# plot sample data -------------------------------------------------------


# generate new samples from wildboar_lags data

ueli_filter <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "wallow" | site_type == "nest",
    TierName == "Ueli"
  ) %>% 
  mutate(site_type = droplevels(site_type))

frida_filter <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "wallow" | site_type == "nest",
    TierName == "Frida"
  ) %>% 
  mutate(site_type = droplevels(site_type))

caro_filter <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "wallow" | site_type == "nest",
    TierName == "Caroline"
  ) %>% 
  mutate(site_type = droplevels(site_type))

wallows_sample <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "wallow", 
    TierName == "Caroline" | TierName == "Ueli" | TierName == "Frida"
  ) %>% 
  mutate(site_type = droplevels(site_type))

nests_sample <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "nest", 
    TierName == "Caroline" | TierName == "Ueli" | TierName == "Frida"
  ) %>% 
  mutate(site_type = droplevels(site_type))



# frida_filter <- wildboar_lags %>%
#   filter(
#     year == 2016,
#     # month == 5,
#     TierName == "Frida",
#     site_type == "nest"
#   )
# 
# caro_filter <- wildboar_lags %>%
#   filter(
#     year == 2016,
#     # month == 5,
#     TierName == "Caroline",
#     # site_type == "nest"
#   )

# Plot site_type
# alter site_type to explore (nest, wallow, both, none and NA)
# alter data to explore different boars

# ggplot(data = ueli_filter, mapping = aes(E, N, colour = segment_id)) +
#   # geom_path() +
#   geom_point() +
#   coord_equal() +
#   labs(title = "Moving segements coloured by segment ID") +
#   theme_classic() +
#   # RStudio crashes if legend.position "bottom" is chosen
#   theme(legend.position = "none")

# Polt interactive map with sample animals ####

# one layer per animal

# tmaptools::palette_explorer()

oranges <- tmaptools::get_brewer_pal("Oranges", n = 3, contrast = c(0.1, 0.9))
purples <- tmaptools::get_brewer_pal("Purples", n = 3, contrast = c(0.1, 0.9))

viridis <- viridisLite::viridis(3, begin = 0.23, end = 0.78)
magma   <- viridisLite::magma  (3, begin = 0.23, end = 0.78)

dark2 <- tmaptools::get_brewer_pal("Dark2", n = 6)
dark_n <- dark2[1:3]
dark_w <- dark2[4:6]


tm_animals <- 
  tmap_mode("view") +
  tm_shape(ueli_filter) +
  tm_symbols(col = "site_type", size = "segment_dur", alpha = 0.5, title.col = "Ueli", 
             palette = c("orange", "purple"), size.lim = c(1, 10)) +
  tm_shape(frida_filter) +
  tm_symbols(col = "site_type", size = "segment_dur", alpha = 0.5, title.col = "Frida", 
             palette = c("orange", "purple"), size.lim = c(1, 10)) +
    tm_shape(caro_filter) +
  tm_symbols(col = "site_type", size = "segment_dur", alpha = 0.5, title.col = "Caroline", 
             palette = c("orange", "purple"), size.lim = c(1, 10))

tm_animals

# one layer per field type (nests and wallos only)

tm_sample <- 
  tmap_mode("view") +
  tm_shape(nests_sample) +
  tm_symbols(col = "TierName", size = "segment_dur", alpha = 0.5, title.col = "Nests", 
             palette = magma, size.lim = c(1, 10)) +
  tm_shape(wallows_sample) +
  tm_symbols(col = "TierName", size = "segment_dur", alpha = 0.5, title.col = "Wallows", 
             palette = viridis, size.lim = c(1, 10))

tm_sample



# unused plots ------------------------------------------------------------


# caro %>%
#   ggplot(aes(E, N)) +
#   geom_path(alpha = 0.5) +
#   geom_point(alpha = 0.5) +
#   theme_bw() +
#   theme(panel.border = element_blank())
#
# caro_3 %>%
#   ggplot(aes(E, N)) +
#   geom_path(alpha = 0.5) +
#   geom_point(alpha = 0.5) +
#   theme_bw() +
#   theme(panel.border = element_blank())
#
# frida %>%
#   ggplot(aes(E, N)) +
#   geom_path(alpha = 0.5) +
#   geom_point(alpha = 0.5) +
#   theme_bw() +
#   theme(panel.border = element_blank())
#
# frida_3 %>%
#   ggplot(aes(E, N)) +
#   geom_path(alpha = 0.5) +
#   geom_point(alpha = 0.5) +
#   theme_bw() +
#   theme(panel.border = element_blank())
#
# ueli %>%
#   ggplot(aes(E, N)) +
#   geom_path(alpha = 0.5) +
#   geom_point(alpha = 0.5) +
#   theme_bw() +
#   theme(panel.border = element_blank())
#
# ueli_3 %>%
#   ggplot(aes(E, N)) +
#   geom_path(alpha = 0.5) +
#   geom_point(alpha = 0.5) +
#   theme_bw() +
#   theme(panel.border = element_blank())
#
# mcp_caro <- caro %>%
#   group_by(TierID, TierName, CollarID) %>%
#   summarise() %>%
#   st_convex_hull()
#
# plot convex hull
#
# tmap_mode("view") +
#   tm_shape(mcp_caro) +
#   tm_fill("TierName", alpha = 0.5) +
#   tm_borders(col = "red", lwd = 1) +
#   tm_layout(legend.bg.color = "white")



# mcp_caro <- caro_filter %>%
#   group_by(site_type, segment_id) %>%
#   summarise() %>%
#   st_convex_hull()
#
# tmap_mode("view") +
#   tm_shape(mcp_caro) +
#   tm_fill("segment_id", alpha = 0.5) +
#   tm_borders(col = "red", lwd = 1) +
#   tm_layout(legend.bg.color = "white")

# step 7 to 8: rasterize data ----------------------------------------------------------

# Erstellen eines raster-templates mit Aufloesung 30m (Analog zu steplenth threshold)
raster_100 <- raster(extent(wildboar_lags), resolution = 100, crs = 2056)
raster_30 <- raster(extent(wildboar_lags), resolution = 30, crs = 2056)

# resting filtern, jeweils ersten datenpunk pro segment id 

resting <- wildboar_lags %>% 
  group_by(segment_id) %>% 
  filter(row_number(segment_id) == 1)

# Wallows und Nests filtern fuer separate Layers, jeweils ersten Datenpunk pro segment id
wallows <- wildboar_lags %>%
  filter(wallow == "TRUE") %>% 
  group_by(segment_id) %>% 
  filter(row_number(segment_id) == 1)

nests <- wildboar_lags %>%
  filter(nest == "TRUE") %>% 
  group_by(segment_id) %>% 
  filter(row_number(segment_id) == 1)


# rasterize data

# Rastern der layer

resting_raster_100 <- raster::rasterize(resting, raster_100, field = 1, fun = "count")
wallows_raster_100 <- raster::rasterize(wallows, raster_100, field = 1, fun = "count")
nests_raster_100 <- raster::rasterize(nests, raster_100, field = 1, fun = "count")

resting_raster_30 <- raster::rasterize(resting, raster_30, field = 1, fun = "count")
wallows_raster_30 <- raster::rasterize(wallows, raster_30, field = 1, fun = "count")
nests_raster_30 <- raster::rasterize(nests, raster_30, field = 1, fun = "count")

# plots

greens <- tmaptools::get_brewer_pal("Greens", n = 6, contrast = c(0.3, 0.9))
oranges <- tmaptools::get_brewer_pal("Oranges", n = 5, contrast = c(0.3, 0.9))
purples <- tmaptools::get_brewer_pal("Purples", n = 5, contrast = c(0.3, 0.9))

# resolution: 100 m

tm_r_100 <- 
  tmap_mode("view") +
  tm_shape(resting_raster_100) +
  tm_raster(palette = greens, title = "Resting sites", alpha = 1)
  
tm_r_100

tm_nw_100 <-
  tmap_mode("view") +
  tm_shape(nests_raster_100) +
  tm_raster(palette = oranges, title = "Nests", alpha = 1) +
  tm_shape(wallows_raster_100) +
  tm_raster(palette = purples, title = "Wallows", alpha = 1) +
  tm_view(control.position = c("right", "top"))

tm_nw_100

# resolution: 30 m

tm_r_30 <- 
  tmap_mode("view") +
  tm_shape(resting_raster_30) +
  tm_raster(palette = greens, title = "Resting sites", alpha = 1)

tm_r_30

tm_nw_30 <-
  tmap_mode("view") +
  tm_shape(nests_raster_30) +
  tm_raster(palette = oranges, title = "Nests", alpha = 1) +
  tm_shape(wallows_raster_30) +
  tm_raster(palette = purples, title = "Wallows", alpha = 1) +
  tm_view(control.position = c("right", "top"))

tm_nw_30


# layer landnutzung: nicht sinnvoll, da unuebersichtlich

# tm +
# tm_shape(feldnutzung) +
# tm_polygon(col = "Frucht")

# leaflet plotten

# layer controls funktionieren nicht richtig

# tm %>%
#   tmap_leaflet() %>%
#   addLayersControl(
#     overlayGroups = c("Nests", "Wallows"),
#     options = layersControlOptions(collapsed = FALSE)
#   )
#

```

# Abstract

Tobias

# Research Questions

(yves) Our research is based on data from the ZHAW research project "Prevention of Wild Boar Damage in Agriculture"[@suter2018]. With this dataset as a basis, we want to answer the following research questions:

-   How can resting sites be modelled based on spatiotemporal movement data?

-   Can locations frequently visited by wild boar be determined efficiently and effectively in the provided research data?

-   Can these regular resting places be clearly defined as nests or wallows?

# Material and Methods

## Data

(yves) The provided data contains spatio-temporal datasets of 39 wildboars which were equipped with the GPS collar VERTEX PLUS [@vectronicaerospace2021]. Some wildboars were equipped multiple times which results in 46 sampling sets. The data was taken between 2014-05-28 and 2016-10-18 around the conservation zone Fanel which belongs to the cantons Bern and Neuenburg. The sampling regime varies widely in duration and interval. The vast majority of the recorded wild boar data has a timelag of 15 minutes (≙ 900 seconds) between two points.

```{r sampling regime, fig.cap="Sampling regime for all individuals in minutes", fig.width=9, fig.height=7, appendix=TRUE}

limits <- c(0,200)
breaks = seq(0,200,50)
labels = paste(c(rep("",length(breaks)-1),">"), breaks)

wildschwein_BE %>%
  mutate(TierName = fct_reorder(TierName, DatetimeUTC,min, .desc = TRUE)) %>%
  group_by(TierID, TierName, CollarID) %>%
  mutate(
    timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC, units = "mins")),
    ) %>%
  ggplot(aes(DatetimeUTC, TierName, colour = timelag)) +
  geom_line(lwd = 10) +
  scale_color_gradientn(name = "Sampling interval", colours = RColorBrewer::brewer.pal(11, "Spectral"), limits = limits, na.value = NA, oob = scales::squish, breaks = seq(0,200,50), labels = labels) +
  theme_minimal() +
  theme(legend.position = "top") +
  guides(color = guide_colorbar(title.position = "top", title.hjust = .5, barwidth = unit(20, "lines"), barheight = unit(.5, "lines")))

```

Furthermore we use spatial information about the vegetation to the spatio-temporal wild boar data. This data is provided by a survey which classified the investigated area in forests, wetlands, settlement and agriculture. If a lot of land was used for agriculture, information about the planted crop is also given. In total the survey evaluated 5154 lots of land, covering an area of 120 km\^2. The evaluated area consists of 63 % agriculture, 22 % forest, 9 % settlement and 6 % wetlands [@suter2010].

## Analytical Concepts

In order to analyse the behavior of wild boars and to be able to distinguish between nests and wallows, the first step is to take a closer look at the trajectories, to filter and segment them [@laube2011].

The *steplength* is calculated based on the Euclidean distance, using the following formula:

$$\text{distance} = \sqrt{(\text{E1} - \text{E2})^{2}+(\text{N1} - \text{N2})^{2}}$$Based on the calculated *steplength*, additional parameters such as *speed* and *timelag* are calculated. In a further step, the average distance within a given temporal window is calculated (*stepmean*) and then used to segment the wildboar data and to differentiate between resting and moving (*movement status*).

Since wild boars usually rest at nests and wallows the parameter movement status builds the basement for further analysis.

### Wild Boar Behavior

Wild boars share a common movement pattern when spending time at wallows and nests: they stick to a location for a certain while and do not undertake wide distances during this time. Distinguishing this behavior from others builds the basement of our analytical concept. Wild boar biologists differentiate between the following wild boar behaviour [@keuling2009]:

-   feeding
-   protective behavior
-   aggressive behavior
-   comfort behavior
-   other behaviour (sleeping, resting, fleeing, strolling)

According to literature wild boar show some behavioral patterns at nests and wallows:

-   **Nests:** Multiple wild boars gather in close distance and stay there for an undefined while [@keuling2009]. Since wild boars are nocturnal animals, they preferably rest in covered areas like forests or wetlands with high reeds. During summertime agricultural fields with high crops like cereal (wheat, barley, oat etc.), rapeseed or corn can also provide a suitable nesting habitat. Surveys in this area showed that wild boars normally rest between 8:00 and 17:00 and revisit its nests up to eight times [@suter2010].

-   **Wallows:** Wild boars use wallows for hygiene purposes [@keuling2009]. In a wallow the boar is able to regulate their body temperature since wild boars cannot sweat. This leads to fact that wallowing happens mainly during summer season and are not observed before April [@fernández-llario2005]. On a daily view, wild boars visit wallows during nighttime and early morning hours [@meynhardt1990]. In comparison to the behavior at nests, wild boars spend less time at wallows since it is clearly a comfort behavior and does not serve a basic need[@keuling2009].

## R Concepts

Tobias

The analysis, visualisation and documentation was conducted in the open-source software R, version 4.0.5 [@rcoreteam2021]. The handling of spatiotemporal data was managed with the packages sf [@pebesma2018], terra [@hijmans2021] and raster [@hijmans2020]. The graphical representations were created with ggplot2 [@wickham2016] as part of tidyverse [@wickham2019], which was also used for general data wrangling, alongside forcats [@wickham2021] to handle factor levels and janitor [@firke2021] for clean and consistent naming. Maps were generated using tmap [@tennekes2018] and leaflet [@cheng2021].

The wildboar data from the ZHAW research project [@suter2010a] is provided in form of the seperate R package ComputationalMovementAnalysis, version 0.1.14 [@ratnaweera2021a].

### Calculation of Movement Parameters

In a prelimary phase we enrich the given data with important parameters for *Computational Movement Analysis*. For every data point we calculate *speed*, *steplength* and *timelag* to the next point.

Another movement parameter we add for our analysis is *stepmean*. It calculates the mean distance within a moving window of six data points. This variable allowes us to apply segmentation on our wild boar data and define stops and moves (Variable *mov_status* with a two factors: *resting* or *moving*).

The mentioned movement parameter are implemented via the function *calc_movement_param*.

```{r calc_movement_param, echo=TRUE, eval=FALSE, class.source = "fold-show"}

calc_movement_param <- function(boar_dt) {
  boar_dt <- boar_dt %>%
    mutate(
      timelag = as.integer(difftime(lead(DatetimeUTC), DatetimeUTC, units = "secs")),
      steplength = sqrt(((E - lead(E, 1))^2 + (N - lead(N, 1))^2)),
      speed = steplength / timelag,
      nMinus3 = sqrt((lag(E, 3) - E)^2 + (lag(N, 3) - N)^2),
      nMinus2 = sqrt((lag(E, 2) - E)^2 + (lag(N, 2) - N)^2),
      nMinus1 = sqrt((lag(E, 1) - E)^2 + (lag(N, 1) - N)^2),
      nPlus1 = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2),
      nPlus2 = sqrt((E - lead(E, 2))^2 + (N - lead(N, 2))^2),
      nPlus3 = sqrt((E - lead(E, 3))^2 + (N - lead(N, 3))^2)
    ) %>%
    rowwise() %>%
    mutate(
      stepmean = mean(c(nMinus3, nMinus2, nMinus1, nPlus1, nPlus2, nPlus3)),
    ) %>%
    ungroup() %>%
    mutate(
      mov_static = if_else(stepmean < segment_trigger, TRUE, FALSE),
      mov_status = if_else(stepmean < segment_trigger, "resting", "moving"),
      cma_static = stepmean < mean(stepmean, na.rm = TRUE)
    )
  boar_dt
}
```

### Filtering and Segmentation

As mentioned above, the majority of the recorded wild boar data has a rounded *timelag* of 900 seconds (≙ 15 minutes) between two points:

```{r time lag hist, message=TRUE, warning=FALSE, fig.cap="Time lag distribution", appendix=TRUE}

hist_lag_cat <- ggplot(wildboar_lag_cat)
hist_lag_cat + geom_col(aes(x = timelag_rounded, y = count)) +
  coord_cartesian(ylim=c(0,200000), xlim=c(0,4000)) +
  labs(x = "rounded timelag [seconds]",
     y = "number of counts", 
     title = "Distribution of timelag between two data points",
     subtitle = "a clear majority is sampled with a timelag of 900 seconds") + 
  theme_bw() +
  theme(panel.border = element_blank())
```

Therefore, we only process observations with a rounded *timelag* of 900 seconds further while we exluce the others.

A clear distinction between *resting* and *moving* is done by the introduction of the variable *segment_trigger*. The appropriate level for this threshold is evaluated in a critical manner. We generate sample data sets from three different wild boars and evaluate them in a histogram. With a binwidth of 5, we are able to see a clear decline in the first bins of stepmean. This leads to our interpretation that wild boars rest on the left side of the histogram and move on the right side.

```{r stepmean_threshold}
stepmean_ueli <- ggplot(ueli_6, aes(x = stepmean, fill = mov_status))
stepmean_ueli + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(x = "Mean steplength [meter]",
   y = "Number of counts", 
   title = "Mean steplength of wildboar Ueli",
   subtitle = "Sample dataset from May 2016 (segment_trigger = 40)")

stepmean_caro <- ggplot(caro_6, aes(x = stepmean, fill = mov_status))
stepmean_caro + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(x = "Mean steplength [meter]",
   y = "Number of counts", 
   title = "Mean steplength of wildboar Caroline",
   subtitle = "Sample dataset from May 2015 (segment_trigger = 40)")

stepmean_frida <- ggplot(frida_6, aes(x = stepmean, fill = mov_status))
stepmean_frida + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(x = "Mean steplength [meter]",
   y = "Number of counts", 
   title = "Mean steplength of wildboar Frida",
   subtitle = "Sample dataset from May 2016 (segment_trigger = 40)")
```

Setting the threshold seems reasonable at the point where stepmean flattens in a distinct manner (see histograms). In our samples this threshold can be anywhere between 30 to 50 meter. The *segment_trigger* is therfore set to 40. This leads to a division of the *movment status* into approximately 32 % resting and 68 % moving at the level of individual observations.

```{r movement status}

pie <- ggplot(mov_status, aes(x = "", y = prop, fill = status)) +
  geom_bar(width = 1, stat = "identity", color = "white") +
  coord_polar("y", start = 0) +
  geom_text(aes(y = lab.ypos, label = prop), color = "white") +
  scale_fill_discrete(name = "Status", labels = c("Resting", "Moving")) +
  theme_void()

pie

```

### Adding Context

The vegetational information is joined with the wild boar observation to add spatial context which can then be used to further differentiate between potential nests and wallows based on literature informations about circadian activity and preferred crop types.

```{r adding context, echo=TRUE, eval=F}

wildboar_lags <- wildboar_lags %>%
  # add wallow and nest criterias according to literature
  # enable line below if you want to filter all NAs in Frucht
  # filter(!is.na(Frucht)) %>%
  mutate(
    wallow_month = if_else(month > 3 & month < 10, TRUE, FALSE),
    wallow_day = case_when(
      day == "Abenddaemmerung" ~ FALSE,
      day == "Morgendaemmerung" ~ TRUE,
      day == "Nacht" ~ FALSE,
      day == "1Nachtviertel" ~ FALSE,
      day == "2Nachtviertel" ~ FALSE,
      day == "3Nachtviertel" ~ FALSE,
      day == "4Nachtviertel" ~ FALSE,
      day == "Tag" ~ TRUE,
      TRUE ~ NA # Default case
    ),
    wallow_area = case_when(
      Frucht == "Feuchtgebiet" ~ TRUE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ FALSE,
      Frucht == "Gerste" ~ FALSE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ FALSE,
      Frucht == "Raps" ~ FALSE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ FALSE,
      Frucht == "Roggen" ~ FALSE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    ),
    nest_day = case_when(
      day == "Abenddaemmerung" ~ FALSE,
      day == "Morgendaemmerung" ~ FALSE,
      day == "Nacht" ~ FALSE,
      day == "1Nachtviertel" ~ FALSE,
      day == "2Nachtviertel" ~ FALSE,
      day == "3Nachtviertel" ~ FALSE,
      day == "4Nachtviertel" ~ FALSE,
      day == "Tag" ~ TRUE,
      TRUE ~ NA # Default case
    ),
    nest_summer_mon = if_else(month >= 5 & month <= 10, TRUE, FALSE),
    nest_winter_mon = if_else(month >= 5 & month <= 10, FALSE, TRUE),
    nest_summer_area = case_when(
      Frucht == "Feuchtgebiet" ~ FALSE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ TRUE,
      Frucht == "Gerste" ~ TRUE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ TRUE,
      Frucht == "Raps" ~ TRUE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ TRUE,
      Frucht == "Roggen" ~ TRUE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    ),
    nest_winter_area = case_when(
      Frucht == "Feuchtgebiet" ~ TRUE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ FALSE,
      Frucht == "Gerste" ~ FALSE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ FALSE,
      Frucht == "Raps" ~ FALSE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ FALSE,
      Frucht == "Roggen" ~ FALSE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    )
  )


```

### Applying criteria for nests and wallows

After adding all the necessary convenience and context variables we are now able to apply the definied criterias to identify potential nests and wallows. In addition, we reduce the observations to one point per segment, while keeping the segment duration in a different viarbale (*segment_dur*) for further processing. The reason for this is that we only want to consider one count per segment in the final results, as the different lengths of the segments would otherwise lead to distorted representations. For example, according to literature and our applied definition, stays at wallows are much shorter than at nests, while the latter can vary greatly in duration.

```{r applying criteria, echo=TRUE, eval=FALSE, class.source = "fold-show"}

wildboar_lags <- wildboar_lags %>%
  group_by(segment_id) %>%
  mutate(segment_dur = n()) %>%
  filter(row_number(segment_id) == 1) %>% # keep first data point per segment only
  ungroup() %>%
  mutate(wallow_dur = if_else(segment_dur <= 3, TRUE, FALSE)) %>%
  filter(mov_status == "resting") %>%
  mutate(
    wallow = if_else(wallow_month & wallow_day & wallow_area & wallow_dur,
      TRUE, FALSE
    ),
    nest = if_else((nest_summer_mon & nest_day & nest_summer_area & segment_dur > 3) |
      (nest_winter_mon & nest_day & nest_winter_area & segment_dur > 3),
    TRUE, FALSE
    ),
    conflict = if_else(nest & wallow, TRUE, FALSE),
    site_type = as.factor(case_when(
      conflict == TRUE ~ "both",
      nest == TRUE ~ "nest",
      wallow == TRUE ~ "wallow",
      !wallow & !nest == TRUE ~ "none",
      TRUE ~ "NA" # Default case
    ))
  )

```

The applied criteria are summarized in the following table:

+----------------------+-------------------------------------------+--------------------+
|                      | Nests                                     | Wallows            |
+======================+===========================================+====================+
| **Movement**         | resting                                   | resting            |
+----------------------+-------------------------------------------+--------------------+
| **Month**            | January to December                       | April to September |
+----------------------+-------------------------------------------+--------------------+
| **Time of day**      | day                                       | day & dawn         |
+----------------------+-------------------------------------------+--------------------+
| **Vegetation**       | forests & wetlands (winter)               | forests & wetlands |
|                      |                                           |                    |
|                      | forests, cereal, corn & rapeseed (summer) |                    |
+----------------------+-------------------------------------------+--------------------+
| **Resting duration** | \> 45 minutes                             | \<= 45 minutes     |
+----------------------+-------------------------------------------+--------------------+

: Applied criteria for nests and wallows

### Visualizing Sample Data

To generate a visual representation of the newly filtered data, we create a sample subset with only three individuals (Carlone, Frida and Ueli) for the year 2016. The layers show potential nests and wallows, color-coded by the individuals. Each point represents one segment while the size of the points corresponds to the segment duration. The two layers can be hidden via the interactive map menu in the top left corner.

The map shows that there is some overlap between Caroline and Frida, while Ueli seems to prefer other areas.

```{r sample subset areas}

tm_sample <- 
  tmap_mode("view") +
  tm_shape(nests_sample) +
  tm_symbols(col = "TierName", size = "segment_dur", alpha = 0.5, title.col = "Nests", 
             palette = magma, size.lim = c(1, 10)) +
  tm_shape(wallows_sample) +
  tm_symbols(col = "TierName", size = "segment_dur", alpha = 0.5, title.col = "Wallows", 
             palette = viridis, size.lim = c(1, 10))

tm_sample

```

A second map shows the same data but without color-coding for the individuals. Here it is clearly visible that (for the chosen sample) potential nests and wallows are not found in clearly distinc areas.

```{r sample subset animals}

tm_animals <- 
  tmap_mode("view") +
  tm_shape(ueli_filter) +
  tm_symbols(col = "site_type", size = "segment_dur", alpha = 0.5, title.col = "Ueli", 
             palette = c("orange", "purple"), size.lim = c(1, 10)) +
  tm_shape(frida_filter) +
  tm_symbols(col = "site_type", size = "segment_dur", alpha = 0.5, title.col = "Frida", 
             palette = c("orange", "purple"), size.lim = c(1, 10)) +
    tm_shape(caro_filter) +
  tm_symbols(col = "site_type", size = "segment_dur", alpha = 0.5, title.col = "Caroline", 
             palette = c("orange", "purple"), size.lim = c(1, 10))

tm_animals

```

### **Rasterizing Data**

# Results / Products

Tobias

Boxplot mit Stepmean, Exemplarische Plots nach Tieren, Raster graphs, Anteile Site Types & Moving / Resting,

Text

# Discussion

Yves

Warum so viele none und auch both? Evtl. Tabelle der Anteile hier bringen.

Forschungsfragen beantworten

Schwellenwerte und Rastergrössen diskutieren

## Risk analysis / Problems

Keine Validierung möglich, Literaturangaben zur Differenzierung nach N/W unzureichend. Intervalle der Messungen diskutieren, nur 15 Min berücksichtigt, dadurch Datenvelrust

Text

# References

Tobias

::: {#refs}
:::

# Appendix

Complete R Script

```{r ref.label = knitr::all_labels(appendix == TRUE), echo=TRUE, eval=FALSE, class.source = "fold-show"}

```
