---
title: "Identifying nests and swallows based on spatiotemporal wild boar data."
subtitle: "Project Works Patterns and Trends in Environmental Data"
author: "Yves Gubelmann and Tobias Wildhaber"
date: "4 July, 2021"
output: 
  bookdown::html_document2:
    toc: true
    toc_float: true
    number_sections: true
    fig_caption: yes
    theme: darkly
    highlight: tango
    code_folding: hide
bibliography: references.bib
csl: apa.csl
---

```{r chunk settings, echo = FALSE, warning=FALSE, message=FALSE}

# echo = FALSE           hides the code from the generated output
# warning = FALSE        hides warnings from the generated output
# message = FALSE        hides messages from the generated output

# To set the setting for all code chunks, use the following code:

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

```

```{r main, include=FALSE, appendix=TRUE}
# libraries ---------------------------------------------------------------

# install package with wildobar data:
# devtools::install_github("ComputationalMovementAnalysis/ComputationalMovementAnalysisData")

library(papeR) # summary tables
library(tidyverse) # tidy essentials (ggplot, purr, tidyr, readr, dplyr)
library(lubridate) # handling dates and time
library(tmap) # map visualization
library(leaflet) # interactive maps
library(terra) # handling spatial data
library(ComputationalMovementAnalysisData) # wild boar data
library(sf) # handling spatial data
library(janitor) # clean and consistent naming
library(forcats) # handling factor levels
library(raster) # rasterizing vector data
library(knitr) # for pretty kables


# globals ----------------------------------------------------------------------

# threshold that triggers the segmentation of the movement trajectory
segment_trigger <- 40

# functions ---------------------------------------------------------------

calc_movement_param <- function(boar_dt) {
  boar_dt <- boar_dt %>%
    mutate(
      timelag = as.integer(difftime(lead(DatetimeUTC), DatetimeUTC, units = "secs")),
      steplength = sqrt(((E - lead(E, 1))^2 + (N - lead(N, 1))^2)),
      speed = steplength / timelag,
      nMinus3 = sqrt((lag(E, 3) - E)^2 + (lag(N, 3) - N)^2),
      nMinus2 = sqrt((lag(E, 2) - E)^2 + (lag(N, 2) - N)^2),
      nMinus1 = sqrt((lag(E, 1) - E)^2 + (lag(N, 1) - N)^2),
      nPlus1 = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2),
      nPlus2 = sqrt((E - lead(E, 2))^2 + (N - lead(N, 2))^2),
      nPlus3 = sqrt((E - lead(E, 3))^2 + (N - lead(N, 3))^2)
    ) %>%
    rowwise() %>%
    mutate(
      stepmean = mean(c(nMinus3, nMinus2, nMinus1, nPlus1, nPlus2, nPlus3)),
    ) %>%
    ungroup() %>%
    mutate(
      mov_static = if_else(stepmean < segment_trigger, TRUE, FALSE),
      mov_status = if_else(stepmean < segment_trigger, "resting", "moving"),
      cma_static = stepmean < mean(stepmean, na.rm = TRUE)
    )
  boar_dt
}

rle_id <- function(vec) {
  x <- rle(vec)$lengths
  as.factor(rep(seq_along(x), times = x))
}

# data import -------------------------------------------------------------

wildboar_raw <- wildschwein_BE
head(wildboar_raw)

wildboar_meta <- wildschwein_metadata
head(wildboar_meta)
#?wildschwein_metadata

wildboar_overlap <- wildschwein_overlap_temp
head(wildboar_overlap)
#?wildschwein_overlap_temp

# import feldaufnahmen
feldaufnahmen <- read_sf("data/Feldaufnahmen_Fanel.gpkg")

# add geometry and time ---------------------------------------------------------

# argument remove = False keeps the coordinates E and N
wildboar_sf <- st_as_sf(wildboar_raw, coords = c("E", "N"), crs = 2056, remove = FALSE)
# join feldaufnahmen with wildboar data
wildboar_sf <- st_join(x = wildboar_sf, y = feldaufnahmen)
# add time
wildboar_sf <- wildboar_sf %>%
  mutate(
    month = month(DatetimeUTC),
    year = year(DatetimeUTC)
  )

# time lags ---------------------------------------------------------

# replace wildboar_raw by wildboar_sf for spatial information
wildboar_lags <- wildboar_sf %>%
  group_by(TierID) %>%
  mutate(timelag = as.integer(difftime(lead(DatetimeUTC), DatetimeUTC), units = "secs"))

# round lags on -2 digits
wildboar_lags$timelag_rounded <- round(wildboar_lags$timelag, -2)

# build categories with rounded lags
wildboar_lag_cat <- wildboar_lags %>%
  st_drop_geometry() %>%
  group_by(timelag_rounded) %>%
  summarise(count = n()) %>% 
  mutate(proportion = count/sum(count) * 100,
       proportion = round(proportion, 1)) %>% 
  arrange(desc(proportion))

wildboar_lag_cat


# preprocessing ---------------------------------------------------------

# assign convenience variables for step 6
wildboar_lags <- wildboar_lags %>%
  # add wallow and nest criterias according to literature
  # enable line below if you want to filter all NAs in Frucht
  # filter(!is.na(Frucht)) %>%
  mutate(
    wallow_month = if_else(month > 3 & month < 10, TRUE, FALSE),
    wallow_day = case_when(
      day == "Abenddaemmerung" ~ FALSE,
      day == "Morgendaemmerung" ~ TRUE,
      day == "Nacht" ~ FALSE,
      day == "1Nachtviertel" ~ FALSE,
      day == "2Nachtviertel" ~ FALSE,
      day == "3Nachtviertel" ~ FALSE,
      day == "4Nachtviertel" ~ FALSE,
      day == "Tag" ~ TRUE,
      TRUE ~ NA # Default case
    ),
    wallow_area = case_when(
      Frucht == "Feuchtgebiet" ~ TRUE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ FALSE,
      Frucht == "Gerste" ~ FALSE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ FALSE,
      Frucht == "Raps" ~ FALSE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ FALSE,
      Frucht == "Roggen" ~ FALSE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    ),
    nest_day = case_when(
      day == "Abenddaemmerung" ~ FALSE,
      day == "Morgendaemmerung" ~ FALSE,
      day == "Nacht" ~ FALSE,
      day == "1Nachtviertel" ~ FALSE,
      day == "2Nachtviertel" ~ FALSE,
      day == "3Nachtviertel" ~ FALSE,
      day == "4Nachtviertel" ~ FALSE,
      day == "Tag" ~ TRUE,
      TRUE ~ NA # Default case
    ),
    nest_summer_mon = if_else(month >= 5 & month <= 10, TRUE, FALSE),
    nest_winter_mon = if_else(month >= 5 & month <= 10, FALSE, TRUE),
    nest_summer_area = case_when(
      Frucht == "Feuchtgebiet" ~ FALSE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ TRUE,
      Frucht == "Gerste" ~ TRUE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ TRUE,
      Frucht == "Raps" ~ TRUE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ TRUE,
      Frucht == "Roggen" ~ TRUE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    ),
    nest_winter_area = case_when(
      Frucht == "Feuchtgebiet" ~ TRUE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ FALSE,
      Frucht == "Gerste" ~ FALSE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ FALSE,
      Frucht == "Raps" ~ FALSE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ FALSE,
      Frucht == "Roggen" ~ FALSE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    )
  )

# This checks a certain variable for NAs
# na_check <- wildboar_lags %>%
#   filter(is.na(wallow_area))

wildboar_lags <- calc_movement_param(wildboar_lags)
wildboar_lags <- wildboar_lags %>%
  # run segment-based analysis with rle_id. copied from cma_week 3
  # choose between: own threshold (mov_static) or from cma_week 3 (cma_static)
  mutate(segment_id = rle_id(mov_static)) %>%
  # select only rows with an certain timelag
  # if no filter is applied, sequencing creates misleading results
  # fraglich, ob der filter hier angewendet werden soll oder nach Sample data
  filter(timelag_rounded == 900)

# visualize movement status --------------------------------------------------

summary(as.factor(wildboar_lags$mov_status))

mov_status <- data.frame(summary(as.factor(wildboar_lags$mov_status))) %>% 
  rename(count = 1) %>% 
  slice(-3) %>% 
  rownames_to_column(var = "status") %>% 
  mutate(prop = count/sum(count) * 100,
         prop = round(prop, 1)) %>% 
  arrange(desc(status)) %>%
  mutate(lab.ypos = cumsum(prop) - 0.5 * prop)

pie <- ggplot(mov_status, aes(x = "", y = prop, fill = status)) +
  geom_bar(width = 1, stat = "identity", color = "white") +
  coord_polar("y", start = 0) +
  geom_text(aes(y = lab.ypos, label = prop), color = "white") +
  scale_fill_discrete(name = "Status", labels = c("Resting", "Moving")) +
  theme_void()

pie

# cross-scale movement analysis ####
seq3 <- seq(from = 1, to = nrow(wildboar_raw), by = 3)
seq6 <- seq(from = 1, to = nrow(wildboar_raw), by = 6)
seq9 <- seq(from = 1, to = nrow(wildboar_raw), by = 9)

# sample data -------------------------------------------------------------

# create a sample of caroline
caro <- wildboar_sf %>%
  filter(
    year == 2015,
    month == 5,
    TierName == "Caroline"
  )

# create a sample of Frida
frida <- wildboar_sf %>%
  filter(
    year == 2016,
    month == 5,
    TierName == "Frida"
  )

# create a sample of Ueli
ueli <- wildboar_sf %>%
  filter(
    year == 2016,
    month == 5,
    TierName == "Ueli"
  )

# for sample data
caro_seq3 <- seq(from = 1, to = nrow(caro), by = 3)
caro_seq6 <- seq(from = 1, to = nrow(caro), by = 6)
frida_seq3 <- seq(from = 1, to = nrow(frida), by = 3)
frida_seq6 <- seq(from = 1, to = nrow(frida), by = 6)
ueli_seq3 <- seq(from = 1, to = nrow(ueli), by = 3)
ueli_seq6 <- seq(from = 1, to = nrow(ueli), by = 6)
caro_3 <- caro %>% slice(caro_seq3)
caro_6 <- caro %>% slice(caro_seq6)
frida_3 <- frida %>% slice(frida_seq3)
frida_6 <- frida %>% slice(frida_seq6)
ueli_3 <- ueli %>% slice(ueli_seq3)
ueli_6 <- ueli %>% slice(ueli_seq6)


# calculate speed, steplength and timelag for sample data ####

# for sample data, for wildboar_lags its already done
caro <- calc_movement_param(caro)
caro_3 <- calc_movement_param(caro_3)
caro_6 <- calc_movement_param(caro_6)
frida <- calc_movement_param(frida)
frida_3 <- calc_movement_param(frida_3)
frida_6 <- calc_movement_param(frida_6)
ueli <- calc_movement_param(ueli)
ueli_3 <- calc_movement_param(ueli_3)
ueli_6 <- calc_movement_param(ueli_6)


# plot mean steplength for sample data ####

stepmean_ueli <- ggplot(ueli_6, aes(x = stepmean, fill = mov_status))
stepmean_ueli <- stepmean_ueli + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  scale_y_continuous(limits = c(0, 40)) +
    geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(
    x = "Mean steplength [m]",
    y = "Number of counts"
    )

stepmean_ueli

stepmean_caro <- ggplot(caro_6, aes(x = stepmean, fill = mov_status))
stepmean_caro <- stepmean_caro + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  scale_y_continuous(limits = c(0, 40)) +
  geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(
    x = "Mean steplength [m]",
    y = "Number of counts"
    )

stepmean_caro

stepmean_frida <- ggplot(frida_6, aes(x = stepmean, fill = mov_status))
stepmean_frida <- stepmean_frida + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  scale_y_continuous(limits = c(0, 40)) +
  geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(
    x = "Mean steplength [m]",
    y = "Number of counts"
  )

stepmean_frida

# assign movement status and apply criterias -----------------


# for all data

wildboar_lags <- wildboar_lags %>%
  group_by(segment_id) %>%
  mutate(segment_dur = n()) %>%
  filter(row_number(segment_id) == 1) %>% # keep only the first data point per segment
  ungroup() %>%
  mutate(wallow_dur = if_else(segment_dur <= 3, TRUE, FALSE)) %>%
  filter(mov_status == "resting") %>%
  mutate(
    wallow = if_else(wallow_month & wallow_day & wallow_area & wallow_dur,
      TRUE, FALSE
    ),
    nest = if_else((nest_summer_mon & nest_day & nest_summer_area & segment_dur > 3) |
      (nest_winter_mon & nest_day & nest_winter_area & segment_dur > 3),
    TRUE, FALSE
    ),
    conflict = if_else(nest & wallow, TRUE, FALSE),
    site_type = as.factor(case_when(
      conflict == TRUE ~ "both",
      nest == TRUE ~ "nest",
      wallow == TRUE ~ "wallow",
      !wallow & !nest == TRUE ~ "none",
      TRUE ~ "NA" # Default case
    ))
  )
  

# check the dataset (number of wallows, nests, NAs etc)

summary(wildboar_lags)

# create pie chart for site_type ####

site_type <- data.frame(summary(wildboar_lags$site_type)) %>% 
  rename(count = 1) %>% 
  rownames_to_column(var = "type") %>% 
  mutate(prop = count/sum(count) * 100,
         prop = round(prop, 1)) %>% 
  arrange(desc(type)) %>%
  mutate(lab.ypos = cumsum(prop) - 0.5 * prop)

pie <- ggplot(site_type, aes(x = "", y = prop, fill = type)) +
  geom_bar(width = 1, stat = "identity", color = "white") +
  coord_polar("y", start = 0) +
  geom_text(aes(y = lab.ypos, label = prop), color = "white") +
  scale_fill_discrete(name = "Type", labels = c("NA", "Nest", "None", "Wallow")) +
  theme_void()

pie


# plot sample data -------------------------------------------------------


# generate new samples from wildboar_lags data

ueli_filter <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "wallow" | site_type == "nest",
    TierName == "Ueli"
  ) %>% 
  mutate(site_type = droplevels(site_type))

frida_filter <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "wallow" | site_type == "nest",
    TierName == "Frida"
  ) %>% 
  mutate(site_type = droplevels(site_type))

caro_filter <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "wallow" | site_type == "nest",
    TierName == "Caroline"
  ) %>% 
  mutate(site_type = droplevels(site_type))

wallows_sample <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "wallow", 
    TierName == "Caroline" | TierName == "Ueli" | TierName == "Frida"
  ) %>% 
  mutate(site_type = droplevels(site_type))

nests_sample <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "nest", 
    TierName == "Caroline" | TierName == "Ueli" | TierName == "Frida"
  ) %>% 
  mutate(site_type = droplevels(site_type))


# Polt interactive map with sample animals ####

# one layer per animal

# tmaptools::palette_explorer()

oranges <- tmaptools::get_brewer_pal("Oranges", n = 3, contrast = c(0.1, 0.9))
purples <- tmaptools::get_brewer_pal("Purples", n = 3, contrast = c(0.1, 0.9))

viridis <- viridisLite::viridis(3, begin = 0.23, end = 0.78)
magma   <- viridisLite::magma  (3, begin = 0.23, end = 0.78)

dark2 <- tmaptools::get_brewer_pal("Dark2", n = 6)
dark_n <- dark2[1:3]
dark_w <- dark2[4:6]


tm_animals <- 
  tmap_mode("view") +
  tm_shape(ueli_filter) +
  tm_symbols(col = "site_type", size = "segment_dur", alpha = 0.5, title.col = "Ueli", 
             palette = c("orange", "purple"), size.lim = c(1, 10)) +
  tm_shape(frida_filter) +
  tm_symbols(col = "site_type", size = "segment_dur", alpha = 0.5, title.col = "Frida", 
             palette = c("orange", "purple"), size.lim = c(1, 10)) +
    tm_shape(caro_filter) +
  tm_symbols(col = "site_type", size = "segment_dur", alpha = 0.5, title.col = "Caroline", 
             palette = c("orange", "purple"), size.lim = c(1, 10)) +
  tm_view(control.position = c("right", "top"))

tm_animals

# one layer per field type (nests and wallos only)

tm_sample <- 
  tmap_mode("view") +
  tm_shape(nests_sample) +
  tm_symbols(col = "TierName", size = "segment_dur", alpha = 0.5, title.col = "Nests", 
             palette = magma, size.lim = c(1, 10)) +
  tm_shape(wallows_sample) +
  tm_symbols(col = "TierName", size = "segment_dur", alpha = 0.5, title.col = "Wallows", 
             palette = viridis, size.lim = c(1, 10)) +
  tm_view(control.position = c("right", "top"))

tm_sample




# rasterize data ----------------------------------------------------------

# Erstellen eines raster-templates mit Aufloesung 30m (Analog zu steplenth threshold)
raster_100 <- raster(extent(wildboar_lags), resolution = 100, crs = 2056)
raster_30 <- raster(extent(wildboar_lags), resolution = 30, crs = 2056)

# resting filtern, jeweils ersten datenpunk pro segment id 

resting <- wildboar_lags #%>% 
#  group_by(segment_id) %>% 
#  filter(row_number(segment_id) == 1)

# Wallows und Nests filtern fuer separate Layers, jeweils ersten Datenpunk pro segment id
wallows <- wildboar_lags %>%
  filter(wallow == "TRUE") #%>% 
#  group_by(segment_id) %>% 
#  filter(row_number(segment_id) == 1)

nests <- wildboar_lags %>%
  filter(nest == "TRUE") # %>% 
#  group_by(segment_id) %>% 
#  filter(row_number(segment_id) == 1)


# rasterize data

# rasterize layers

resting_raster_100 <- raster::rasterize(resting, raster_100, field = 1, fun = "count")
wallows_raster_100 <- raster::rasterize(wallows, raster_100, field = 1, fun = "count")
nests_raster_100 <- raster::rasterize(nests, raster_100, field = 1, fun = "count")

resting_raster_30 <- raster::rasterize(resting, raster_30, field = 1, fun = "count")
wallows_raster_30 <- raster::rasterize(wallows, raster_30, field = 1, fun = "count")
nests_raster_30 <- raster::rasterize(nests, raster_30, field = 1, fun = "count")

# plots

greens <- tmaptools::get_brewer_pal("Greens", n = 6, contrast = c(0.3, 0.9))
oranges <- tmaptools::get_brewer_pal("Oranges", n = 5, contrast = c(0.3, 0.9))
purples <- tmaptools::get_brewer_pal("Purples", n = 5, contrast = c(0.3, 0.9))

# resolution: 100 m

tm_r_100 <- 
  tmap_mode("view") +
  tm_shape(resting_raster_100) +
  tm_raster(palette = greens, title = "Resting sites", alpha = 1) +
  tm_view(control.position = c("right", "top"))
  
tm_r_100

tm_nw_100 <-
  tmap_mode("view") +
  tm_shape(nests_raster_100) +
  tm_raster(palette = oranges, title = "Nests", alpha = 1) +
  tm_shape(wallows_raster_100) +
  tm_raster(palette = purples, title = "Wallows", alpha = 1) +
  tm_view(control.position = c("right", "top"))

tm_nw_100

# resolution: 30 m

tm_r_30 <- 
  tmap_mode("view") +
  tm_shape(resting_raster_30) +
  tm_raster(palette = greens, title = "Resting sites", alpha = 1) +
  tm_view(control.position = c("right", "top"))

tm_r_30

tm_nw_30 <-
  tmap_mode("view") +
  tm_shape(nests_raster_30) +
  tm_raster(palette = oranges, title = "Nests", alpha = 1) +
  tm_shape(wallows_raster_30) +
  tm_raster(palette = purples, title = "Wallows", alpha = 1) +
  tm_view(control.position = c("right", "top"))

tm_nw_30

```

# Abstract

Due to the ongoing optimization of harvesting methods in agriculture, the prevention of wild boar damages has become increasingly popular in recent years. Understanding the selection of resting places like nests and wallows build the basis for effective management measures. Based on spatiotemporal data of wild boars we try to determine such resting places and allocate them to surrounding crops.

# Research Questions

Our research is based on data from the ZHAW research project "Prevention of Wild Boar Damage in Agriculture"[@suter2018]. With this dataset as a basis, we want to answer the following research questions:

-   How can resting sites be modelled based on spatiotemporal movement data?

-   Can locations frequently visited by wild boar be determined efficiently and effectively in the provided research data?

-   Can these regular resting places be clearly defined as nests or wallows?

# Material and Methods

## Data

The provided data contains spatio-temporal datasets of 39 wildboars which were equipped with the GPS collar VERTEX PLUS [@vectronicaerospace2021]. Some wildboars were equipped multiple times which results in 46 sampling sets. The data was taken between 2014-05-28 and 2016-10-18 around the conservation zone Fanel which belongs to the cantons Bern and Neuenburg. The sampling regime varies widely in duration and interval (Figure \@ref(fig:sampling-regime)). The vast majority of the recorded wild boar data has a timelag of 15 minutes (≙ 900 seconds) between two points.

```{r sampling-regime, fig.width=9, fig.height=7.5, appendix=TRUE, fig.cap="Sampling regime for all individuals in minutes"}

limits <- c(0,200)
breaks = seq(0,200,50)
labels = paste(c(rep("",length(breaks)-1),">"), breaks)

wildschwein_BE %>%
  mutate(TierName = fct_reorder(TierName, DatetimeUTC,min, .desc = TRUE)) %>%
  group_by(TierID, TierName, CollarID) %>%
  mutate(
    timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC, units = "mins")),
    ) %>%
  ggplot(aes(DatetimeUTC, TierName, colour = timelag)) +
  geom_line(lwd = 10) +
  scale_color_gradientn(name = "Sampling interval", colours = RColorBrewer::brewer.pal(11, "Spectral"), limits = limits, na.value = NA, oob = scales::squish, breaks = seq(0,200,50), labels = labels) +
  theme_minimal() +
  theme(legend.position = "top") +
  guides(color = guide_colorbar(title.position = "top", title.hjust = .5, barwidth = unit(20, "lines"), barheight = unit(.5, "lines")))

```

Furthermore we use spatial information about the vegetation to the spatio-temporal wild boar data. This data is provided by a survey which classified the investigated area in forests, wetlands, settlement and agriculture. If a lot of land was used for agriculture, information about the planted crop is also given. In total the survey evaluated 5154 lots of land, covering an area of 120 km\^2. The evaluated area consists of 63 % agriculture, 22 % forest, 9 % settlement and 6 % wetlands [@suter2010].

## Analytical Concepts

In order to analyse the behavior of wild boars and to be able to distinguish between nests and wallows, the first step is to take a closer look at the trajectories, to filter and segment them [@laube2011].

The *steplength* is calculated based on the Euclidean distance, using the following formula:

$$\text{distance} = \sqrt{(\text{E1} - \text{E2})^{2}+(\text{N1} - \text{N2})^{2}}$$

Based on the calculated *steplength*, additional parameters such as *speed* and *timelag* are calculated. In a further step, the average distance within a given temporal window is calculated (*stepmean*) and then used to segment the wildboar data and to differentiate between resting and moving (*movement status*).

Since wild boars usually rest at nests and wallows the parameter movement status builds the basement for further analysis.

### Wild Boar Behavior

Wild boars share a common movement pattern when spending time at wallows and nests: they stick to a location for a certain while and do not undertake wide distances during this time. Distinguishing this behavior from others builds the basement of our analytical concept. Wild boar biologists differentiate between the following wild boar behaviour [@keuling2009]:

-   feeding
-   protective behavior
-   aggressive behavior
-   comfort behavior
-   other behaviour (sleeping, resting, fleeing, strolling)

According to literature wild boar show some behavioral patterns at nests and wallows:

-   **Nests:** Multiple wild boars gather in close distance and stay there for an undefined while [@keuling2009]. Since wild boars are nocturnal animals, they preferably rest in covered areas like forests or wetlands with high reeds. During summertime agricultural fields with high crops like cereal (wheat, barley, oat etc.), rapeseed or corn can also provide a suitable nesting habitat. Surveys in this area showed that wild boars normally rest between 8:00 and 17:00 and revisit its nests up to eight times [@suter2010].

-   **Wallows:** Wild boars use wallows for hygiene purposes [@keuling2009]. In a wallow the boar is able to regulate their body temperature since wild boars cannot sweat. This leads to fact that wallowing happens mainly during summer season and are not observed before April [@fernández-llario2005]. On a daily view, wild boars visit wallows during nighttime and early morning hours [@meynhardt1990]. In comparison to the behavior at nests, wild boars spend less time at wallows since it is clearly a comfort behavior and does not serve a basic need[@keuling2009].

## R Concepts

The analysis, visualisation and documentation was conducted in the open-source software R, version 4.0.5 [@rcoreteam2021]. The handling of spatiotemporal data was managed with the packages sf [@pebesma2018], terra [@hijmans2021] and raster [@hijmans2020]. The graphical representations were created with ggplot2 [@wickham2016] as part of tidyverse [@wickham2019], which was also used for general data wrangling, alongside forcats [@wickham2021] to handle factor levels and janitor [@firke2021] for clean and consistent naming. Maps were generated using tmap [@tennekes2018] and leaflet [@cheng2021]. The reports are generated by using knitr [@xie2021; @xie2015;@xie2014a] and papeR [@hofner2021].

The wildboar data from the ZHAW research project [@suter2018] is provided in form of the seperate R package ComputationalMovementAnalysis, version 0.1.14 [@ratnaweera2021a].

### Calculating Movement Parameters

In a prelimary phase we enrich the given data with important parameters for *Computational Movement Analysis*. For every data point we calculate *speed*, *steplength* and *timelag* to the next point.

Another movement parameter we add for our analysis is *stepmean*. It calculates the mean distance within a moving window of six data points. This variable allowes us to apply segmentation on our wild boar data and define stops and moves (Variable *mov_status* with a two factors: *resting* or *moving*).

The mentioned movement parameter are implemented via the function *calc_movement_param*.

```{r calc_movement_param, echo=TRUE, eval=FALSE, class.source = "fold-show"}

calc_movement_param <- function(boar_dt) {
  boar_dt <- boar_dt %>%
    mutate(
      timelag = as.integer(difftime(lead(DatetimeUTC), DatetimeUTC, units = "secs")),
      steplength = sqrt(((E - lead(E, 1))^2 + (N - lead(N, 1))^2)),
      speed = steplength / timelag,
      nMinus3 = sqrt((lag(E, 3) - E)^2 + (lag(N, 3) - N)^2),
      nMinus2 = sqrt((lag(E, 2) - E)^2 + (lag(N, 2) - N)^2),
      nMinus1 = sqrt((lag(E, 1) - E)^2 + (lag(N, 1) - N)^2),
      nPlus1 = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2),
      nPlus2 = sqrt((E - lead(E, 2))^2 + (N - lead(N, 2))^2),
      nPlus3 = sqrt((E - lead(E, 3))^2 + (N - lead(N, 3))^2)
    ) %>%
    rowwise() %>%
    mutate(
      stepmean = mean(c(nMinus3, nMinus2, nMinus1, nPlus1, nPlus2, nPlus3)),
    ) %>%
    ungroup() %>%
    mutate(
      mov_static = if_else(stepmean < segment_trigger, TRUE, FALSE),
      mov_status = if_else(stepmean < segment_trigger, "resting", "moving"),
      cma_static = stepmean < mean(stepmean, na.rm = TRUE)
    )
  boar_dt
}
```

### Filtering and Segmentation {.tabset}

As mentioned above, the majority of the recorded wild boar data has a rounded *timelag* of 900 seconds (≙ 15 minutes) between two points (Figure \@ref(fig:timelag)). Therefore, we only process observations with a rounded *timelag* of 900 seconds further while we exluce the others.

```{r timelag, message=TRUE, warning=FALSE, fig.cap="Distribution of timelag between two data points. A clear majority is sampled with a timelag of 900 seconds.", appendix=TRUE, fig.align = 'center'}

hist_lag_cat <- ggplot(wildboar_lag_cat)
hist_lag_cat + geom_col(aes(x = timelag_rounded, y = count)) +
  coord_cartesian(ylim=c(0,200000), xlim=c(0,4000)) +
  labs(x = "rounded timelag [seconds]",
     y = "number of counts") + 
  theme_bw() +
  theme(panel.border = element_blank())
```

A clear distinction between *resting* and *moving* is done by the introduction of the variable *segment_trigger*. The appropriate level for this threshold is evaluated in a critical manner. We generate sample data sets from three different wild boars and evaluate them in a histogram. With a binwidth of 5, we are able to see a clear decline in the first bins of stepmean. This leads to our interpretation that wild boars rest on the left side of the histogram and move on the right side.

#### Ueli {.unnumbered}

```{r stepmean-ueli, appendix=FALSE, fig.cap="Mean steplength if wildboar Ueli. Sample dataset from May 2016. Threshold set to 40 meter.", fig.align='center'}

stepmean_ueli

```

#### Caroline {.unnumbered}

```{r stepmean-caro, appendix=FALSE, fig.cap="Mean steplength if wildboar Ueli. Sample dataset from May 2016. Threshold set to 40 meter.", fig.align='center'}

stepmean_caro

```

#### Frida {.unnumbered}

```{r stepmean-frida, appendix=FALSE, fig.cap="Mean steplength if wildboar Ueli. Sample dataset from May 2016. Threshold set to 40 meter.", fig.align='center'}

stepmean_frida

```

###  {.unnumbered}

Setting the threshold seems reasonable at the point where stepmean flattens in a distinct manner (see histograms). In our samples this threshold can be anywhere between 30 to 50 meter. The *segment_trigger* is therfore set to 40. This leads to a division of the *movment status* into approximately 32 % resting and 68 % moving at the level of individual observations (Figure \@ref(fig:movement-status)).

```{r movement-status, fig.cap="Pie chart of movement status at the level of individual observations", fig.align='center'}

pie <- ggplot(mov_status, aes(x = "", y = prop, fill = status)) +
  geom_bar(width = 1, stat = "identity", color = "white") +
  coord_polar("y", start = 0) +
  geom_text(aes(y = lab.ypos, label = prop), color = "white") +
  scale_fill_discrete(name = "Status", labels = c("Resting", "Moving")) +
  theme_void()

pie

```

### Adding Context {#adding-context}

The vegetational information is joined with the wild boar observation to add spatial context which can then be used to further differentiate between potential nests and wallows based on literature informations about circadian activity and preferred crop types.

```{r adding-context, eval=F, echo=TRUE}

wildboar_lags <- wildboar_lags %>%
  # add wallow and nest criterias according to literature
  # enable line below if you want to filter all NAs in Frucht
  # filter(!is.na(Frucht)) %>%
  mutate(
    wallow_month = if_else(month > 3 & month < 10, TRUE, FALSE),
    wallow_day = case_when(
      day == "Abenddaemmerung" ~ FALSE,
      day == "Morgendaemmerung" ~ TRUE,
      day == "Nacht" ~ FALSE,
      day == "1Nachtviertel" ~ FALSE,
      day == "2Nachtviertel" ~ FALSE,
      day == "3Nachtviertel" ~ FALSE,
      day == "4Nachtviertel" ~ FALSE,
      day == "Tag" ~ TRUE,
      TRUE ~ NA # Default case
    ),
    wallow_area = case_when(
      Frucht == "Feuchtgebiet" ~ TRUE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ FALSE,
      Frucht == "Gerste" ~ FALSE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ FALSE,
      Frucht == "Raps" ~ FALSE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ FALSE,
      Frucht == "Roggen" ~ FALSE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    ),
    nest_day = case_when(
      day == "Abenddaemmerung" ~ FALSE,
      day == "Morgendaemmerung" ~ FALSE,
      day == "Nacht" ~ FALSE,
      day == "1Nachtviertel" ~ FALSE,
      day == "2Nachtviertel" ~ FALSE,
      day == "3Nachtviertel" ~ FALSE,
      day == "4Nachtviertel" ~ FALSE,
      day == "Tag" ~ TRUE,
      TRUE ~ NA # Default case
    ),
    nest_summer_mon = if_else(month >= 5 & month <= 10, TRUE, FALSE),
    nest_winter_mon = if_else(month >= 5 & month <= 10, FALSE, TRUE),
    nest_summer_area = case_when(
      Frucht == "Feuchtgebiet" ~ FALSE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ TRUE,
      Frucht == "Gerste" ~ TRUE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ TRUE,
      Frucht == "Raps" ~ TRUE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ TRUE,
      Frucht == "Roggen" ~ TRUE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    ),
    nest_winter_area = case_when(
      Frucht == "Feuchtgebiet" ~ TRUE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ FALSE,
      Frucht == "Gerste" ~ FALSE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ FALSE,
      Frucht == "Raps" ~ FALSE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ FALSE,
      Frucht == "Roggen" ~ FALSE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    )
  )


```

### Applying criteria for nests and wallows

After adding all the necessary convenience and context variables we are now able to apply the definied criterias to identify potential nests and wallows. In addition, we reduce the observations to one point per segment, while keeping the segment duration in a different viarbale (*segment_dur*) for further processing. The reason for this is that we only want to consider one count per segment in the final results, as the different lengths of the segments would otherwise lead to distorted representations. For example, according to literature and our applied definition, stays at wallows are much shorter than at nests, while the latter can vary greatly in duration.

```{r applying-criteria, echo=TRUE, eval=FALSE, class.source = "fold-show"}

wildboar_lags <- wildboar_lags %>%
  group_by(segment_id) %>%
  mutate(segment_dur = n()) %>%
  filter(row_number(segment_id) == 1) %>% # keep first data point per segment only
  ungroup() %>%
  mutate(wallow_dur = if_else(segment_dur <= 3, TRUE, FALSE)) %>%
  filter(mov_status == "resting") %>%
  mutate(
    wallow = if_else(wallow_month & wallow_day & wallow_area & wallow_dur,
      TRUE, FALSE
    ),
    nest = if_else((nest_summer_mon & nest_day & nest_summer_area & segment_dur > 3) |
      (nest_winter_mon & nest_day & nest_winter_area & segment_dur > 3),
    TRUE, FALSE
    ),
    conflict = if_else(nest & wallow, TRUE, FALSE),
    site_type = as.factor(case_when(
      conflict == TRUE ~ "both",
      nest == TRUE ~ "nest",
      wallow == TRUE ~ "wallow",
      !wallow & !nest == TRUE ~ "none",
      TRUE ~ "NA" # Default case
    ))
  )

```

### Visualizing Sample Data {.tabset}

To generate a visual representation of the newly filtered data, we create a sample subset with only three individuals (Carlone, Frida and Ueli) for the year 2016. The layers show potential nests and wallows, color-coded by the individuals. The two layers can be toggled on and off via the interactive map menu in the top right corner. Each point represents one segment while the size of the points corresponds to the segment duration. The map shows that there is some overlap between Caroline and Frida, while Ueli seems to prefer other areas.

The second tab shows a map of the the same data but without color-coding for the individuals. Here it is clearly visible that (for the chosen sample) potential nests and wallows are not found in clearly distinc areas.

#### Nests and Wallows {.unnumbered}

```{r sample-areas, out.width = '100%'}

tm_sample

```

#### Individuals {.unnumbered}

```{r sample-animals, out.width = '100%'}

tm_animals

```

### **Rasterizing Data**

The last step to create a map of potential nests and wallows is to visualize the complete data. Since a vector-based map with around 6000 segments would be very confusing, a rasterised map is created instead. To do this, an empty grid is created with the raster package [@hijmans2020a] and then placed over the filtered data with the `raster::rasterize` command while applying the `count` function.

# Results

The table below shows the applied criteria to differnetiate between nests and wallows. Based on this selection, it is obvious that there is some overlap. Especially the vegetation as well as the time of day are in large parts identical. Differentiation takes place in particular on the basis of the duration of rest, with the threshold value being 45 minutes (which corresponds to a segment duration of 3).

+----------------------+-------------------------------------------+--------------------+
|                      | Nests                                     | Wallows            |
+======================+===========================================+====================+
| **Movement**         | resting                                   | resting            |
+----------------------+-------------------------------------------+--------------------+
| **Month**            | January to December                       | April to September |
+----------------------+-------------------------------------------+--------------------+
| **Time of day**      | day                                       | day & dawn         |
+----------------------+-------------------------------------------+--------------------+
| **Vegetation**       | forests & wetlands (winter)               | forests & wetlands |
|                      |                                           |                    |
|                      | forests, cereal, corn & rapeseed (summer) |                    |
+----------------------+-------------------------------------------+--------------------+
| **Resting duration** | \> 45 minutes                             | \<= 45 minutes     |
+----------------------+-------------------------------------------+--------------------+

: Table 4.1: Applied criteria for nests and wallows

The application of these criteria on a segment level results in a division into approx. 16 % nests and 4 % wallows. 75 % of the segments do not fall into either category, 3.9 % are NA values (Figure \@ref(fig:pie-site-type)).

```{r pie-site-type, fig.cap="Pie chart of segment type by identity.", fig.align='center'}

pie <- ggplot(site_type, aes(x = "", y = prop, fill = type)) +
  geom_bar(width = 1, stat = "identity", color = "white") +
  coord_polar("y", start = 0) +
  geom_text(aes(y = lab.ypos, label = prop), color = "white") +
  scale_fill_discrete(name = "Type", labels = c("NA", "Nest", "None", "Wallow")) +
  theme_void()

pie

```

All generated raster maps are produced in two resolutions each: 100 m and 30 m. The reason for this is that 100 m corresponds to the area statistics of the federal government [@bundesamtfürstatistikbfs2017] and thus to the publicly available data on land use (and thus vegetation). However, since the vegetation data from the ZHAW research project used here are of higher resolution, an additional representation with a 30 m grid is shown as well. All maps are interactive and can be enlarged and reduced using the plus and minus buttons in the top left corner.

## Resting Sites {.tabset}

A map of all the resting sites, meaning nests and wallows, shows that most raster cells are part of the lowest count category (0 to 50) segments. The highest concentration seems to be in the north-western part of the observed area near the lake in a wetland-area. This image becomes even clearer in the 30 m raster map (see second tab.

### 100 m Raster {.unnumbered}

```{r resting-sites-100, out.width = '100%'}

tm_r_100

```

### 30 m Raster {.unnumbered}

```{r resting-sites-30, out.width = '100%'}

tm_r_30

```

## Nests and Wallows {.tabset}

The maps differentiated by nests and wallows confirm this concentration in the wetland for both types of use, although for wallows there appears to be another hotspot to the north in a wooded area. The overlapping, which has already been shown in the sample, is also recognisable here. To display only nests or wallows, the other layer can be hidden in the menu at the top right.

The higher resolution map shows a somewhat clearer differentiation between nests and wallows, although the picture of hotspots is also confirmed here and the most frequently visited sites are very close to each other. It should also be noted that the density of nests is much higher than that of wallows.

### 100 m Raster {.unnumbered}

```{r nest-wallows-100, out.width = '100%'}

tm_nw_100

```

### 30 m Raster {.unnumbered}

```{r nest-wallows-30, out.width = '100%'}

tm_nw_30

```

# Discussion

```{r echo=FALSE, results='asis'}
wildboar_lag_cat <- wildboar_lag_cat %>% 
  filter(count >= 100)
```

The present project work shows one possible approach to modell resting sites based on spatiotemporal movement data. With the calculation of a movement status we are able to distinguish between resting phases and moving phases. The threshold of this classification is based on sample datasets which we use for an simple assessment. Due to missing field data, this assessment method clearly lacks of validation and introduces uncertainty in the following analysis.

The given research data provides a unique sampling regime with different timelags. With the aim to reduce complexity we only used trajectories with a timelag of 900 seconds. This results in a loss of 42.1 % of the provided dataset. On a first glance, a loss of 42.1 % seems like a problematic amount. At a second look this can be justified since 31.2 % has an invalid timelag of zero seconds. If one subtracts this portion, our analysis is able to assess roughly 84 % of all given trajectories which can be considered as effective. According to our research question the effectiveness is only considered for resting sites. Nonetheless it is worth mentioning that the effectiveness decreases rapidly when one looks at the final results of assigned nests and wallows. Only 20.7 % could be assigned to a nest or a wallow.

```{r echo=FALSE, results='asis'}

kable(wildboar_lag_cat, caption = "Proportion of rounded timelags in provided dataset")
```

The clear assignment of nests and wallows is the most challenging task. In our work we base our criterias for the assignment on a mix of analyzed movement trajectories and preferred habitat use which we derived from literature. We are able to assign 16.4 % of all resting sites to nests, 4.3 % to wallows. The fact that assigned number of nests is four times higher than wallows seems valid. Wild boars spend more time with basic needs than comfort behavior like wallowing [@keuling2009].

Furthermore it seems valid that about 75 % is not assigned to a nest or wallow since the criteria (month, day and area) are logical AND-linked. When an evaluation of the processed data is done, it becomes clear that already the daytime has a big impact on the assignment. For nests and wallows, about two thirds of all segments are not suitable as resting site.

```{r echo=FALSE, appendix=TRUE}

wildboar_lags <- wildboar_lags %>% 
  mutate(
    nest_day = factor(nest_day),
    wallow_day = factor(wallow_day),
    wallow_area = as.character(wallow_area),
#    wallow_area = droplevels(wallow_area),
    wallow_area = replace_na(wallow_area, "NA"),
    wallow_area = factor(wallow_area)
    ) 

wildboar_lags$wallow_area <- wildboar_lags$wallow_area %>% replace_na("NA")

knitr::kable(
  papeR::summarize(wildboar_lags, 
                              variables = c("nest_day", "wallow_day", "wallow_area"),                               type = "factor"), caption = "Summary table for the daytime variables for nests and wallows and the area variable for wallows."
  )


# summary(wildboar_lags$nest_day)
# summary(wildboar_lags$wallow_day)

```

A small proportion of segments are assigned with NA. This is clearly caused by missing field information:

```{r echo=FALSE, appendix=TRUE}

# summary(wildboar_lags$wallow_area)


```

A closer interpretation of the processed data shows that we are able to assign nests and wallows to potential resting sites. It is also clear that using logical AND-links tend to provide results with a rather conservative interpretation. Another - underlying - uncertainty is the threshold which distinguishes between moving and resting trajectories. This threshold and all results lack clearly of validation.

Apart from the stated uncertainties, we are confident that we have developed a robust method for the assignment of resting sites. Nevertheless, the developed method requires fine tuning and a validation of the results.

Schwellenwerte und Rastergrössen diskutieren

## Risk analysis / Problems

Keine Validierung möglich, Literaturangaben zur Differenzierung nach N/W unzureichend. Intervalle der Messungen diskutieren, nur 15 Min berücksichtigt, dadurch Datenvelrust

Text

# References

::: {#refs}
:::

# Appendix

## Complete R Script {.unnumbered}

```{r ref.label = knitr::all_labels(appendix == TRUE), echo=TRUE, eval=FALSE, class.source = "fold-show"}

```
