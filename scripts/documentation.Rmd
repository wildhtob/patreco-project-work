---
title: "Identifying nests and swallows based on spatiotemporal wild boar data."
subtitle: "Project Works Patterns and Trends in Environmental Data"
author: "Yves Gubelmann and Tobias Wildhaber"
date: "4 July, 2021"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: darkly
    highlight: tango
    code_folding: hide
bibliography: references.bib
csl: apa.csl
---

```{r chunk settings, echo = TRUE, warning=FALSE, message=FALSE}

# You can set chunk options individually per code chunk, as was done with this
# code chunk.

# echo = FALSE           hides the code from the generated output
# warning = FALSE        hides warnings from the generated output
# message = FALSE        hides messages from the generated output

# To set the setting for all code chunks, use the following code:

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

```

```{r main, echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
# libraries ---------------------------------------------------------------

# install package with wildobar data:
# devtools::install_github("ComputationalMovementAnalysis/ComputationalMovementAnalysisData")

library(tidyverse) # tidy essentials (ggplot, purr, tidyr, readr, dplyr)
library(lubridate) # handling dates and time
library(tmap) # map visualization
library(leaflet) # interactive maps
library(terra) # handling spatial data
library(ComputationalMovementAnalysisData) # wild boar data
library(sf) # handling spatial data
library(janitor) # clean and consistent naming
library(forcats) # handling factor levels
library(raster) # rasterizing vector data

# globals ----------------------------------------------------------------------
# change working directory
# setwd(r"(C:\code_wc\Modul_CMA\patreco-project-work)")

# auskommentiert, da zu Fehlermeldung gefuehrt, stattdessen in Global Options unter # R Markdown "Evaluate junks in directory" auf "Project" umstellen

# threshold that triggers the segmentation of the movement trajectory

segment_trigger <- 40

# functions ---------------------------------------------------------------

calc_movement_param <- function(boar_dt) {
  boar_dt <- boar_dt %>%
    mutate(
      timelag = as.integer(difftime(lead(DatetimeUTC), DatetimeUTC, units = "secs")),
      steplength = sqrt(((E - lead(E, 1))^2 + (N - lead(N, 1))^2)),
      speed = steplength / timelag,
      nMinus3 = sqrt((lag(E, 3) - E)^2 + (lag(N, 3) - N)^2),
      nMinus2 = sqrt((lag(E, 2) - E)^2 + (lag(N, 2) - N)^2),
      nMinus1 = sqrt((lag(E, 1) - E)^2 + (lag(N, 1) - N)^2),
      nPlus1 = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2),
      nPlus2 = sqrt((E - lead(E, 2))^2 + (N - lead(N, 2))^2),
      nPlus3 = sqrt((E - lead(E, 3))^2 + (N - lead(N, 3))^2)
    ) %>%
    rowwise() %>%
    mutate(
      stepmean = mean(c(nMinus3, nMinus2, nMinus1, nPlus1, nPlus2, nPlus3)),
    ) %>%
    ungroup() %>%
    mutate(
      mov_static = if_else(stepmean < segment_trigger, TRUE, FALSE),
      mov_status = if_else(stepmean < segment_trigger, "resting", "moving"),
      cma_static = stepmean < mean(stepmean, na.rm = TRUE)
    )
  boar_dt
}

rle_id <- function(vec) {
  x <- rle(vec)$lengths
  as.factor(rep(seq_along(x), times = x))
}

# data import -------------------------------------------------------------

wildboar_raw <- wildschwein_BE
head(wildboar_raw)

wildboar_meta <- wildschwein_metadata
head(wildboar_meta)
?wildschwein_metadata

wildboar_overlap <- wildschwein_overlap_temp
head(wildboar_overlap)
?wildschwein_overlap_temp

# import feldaufnahmen
feldaufnahmen <- read_sf("data/Feldaufnahmen_Fanel.gpkg")

# add geometry and time---------------------------------------------------------

# argument remove = False keeps the coordinates E and N
wildboar_sf <- st_as_sf(wildboar_raw, coords = c("E", "N"), crs = 2056, remove = FALSE)
# join feldaufnahmen with wildboar data
wildboar_sf <- st_join(x = wildboar_sf, y = feldaufnahmen)
# add time
wildboar_sf <- wildboar_sf %>%
  mutate(
    month = month(DatetimeUTC),
    year = year(DatetimeUTC)
  )

# data exploration --------------------------------------------------------

# plotting data points ####
#
# ggplot(wildboar_sf, aes(color = TierName)) +
#   geom_sf(alpha = 0.4) +
#   coord_sf(datum = 2056)
#
# ggplot(wildboar_sf, aes(color = as.factor(TierID))) +
#   geom_sf(alpha = 0.4) +
#   coord_sf(datum = 2056) +
#   scale_color_discrete(name = "AnimalID")

# sampling regime ####
#
# limits <- c(0,200)
# breaks = seq(0,200,50)
# labels = paste(c(rep("",length(breaks)-1),">"), breaks)
#
# sampling_regime <- wildboar_raw %>%
#   mutate(TierName = fct_reorder(TierName, DatetimeUTC,min, .desc = TRUE)) %>%
#   group_by(TierID, TierName, CollarID) %>%
#   mutate(
#     timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC, units = "mins")),
#   ) %>%
#   ggplot(aes(DatetimeUTC, TierName, colour = timelag)) +
#   geom_line(lwd = 10) +
#   scale_color_gradientn(name = "Sampling interval", colours = RColorBrewer::brewer.pal(11, "Spectral"), limits = limits, na.value = NA, oob = scales::squish, breaks = seq(0,200,50), labels = labels) +
#   theme_minimal() +
#   theme(legend.position = "top") +
#   guides(color = guide_colorbar(title.position = "top", title.hjust = .5, barwidth = unit(20, "lines"), barheight = unit(.5, "lines")))

# temporal overlap ####

# ?wildschwein_overlap_temp
#
# sampling_periods <- wildboar_raw %>%
#   group_by(TierID, TierName, CollarID) %>%
#   summarise(
#     min = min(DatetimeUTC),
#     max = max(DatetimeUTC)
#   )
#
# wildboar_overlap <- wildboar_overlap %>%
#   left_join(sampling_periods, by = c("TierID", "TierName", "CollarID"))
#
# wildboar_overlap %>%
#   mutate(TierCollar = paste(TierName, CollarID)) %>%
#   ggplot(aes(xmin = min, xmax = max, y = TierCollar)) +
#   geom_errorbarh() +
#   facet_grid(Groups~., scales = "free_y", space = "free_y")
#
# ggplot(wildboar_sf, aes(x = DatetimeUTC, y = TierName)) +
#   geom_point() +
#   scale_x_datetime(breaks = "1 month") +
#   theme_grey()


# spatial overlap ####

# convex hull ####
#
# wildboar_sf <- wildboar_sf %>%
#   mutate(tiercollar = paste(TierID, TierName, CollarID))
#
# mcp <- wildboar_sf %>%
#   group_by(TierID, TierName, CollarID) %>%
#   summarise() %>%
#   st_convex_hull()

# plot convex hull ####
#
# mcp %>%
#   mutate(tiercollar = paste(TierID, TierName, CollarID)) %>%
#   ggplot(aes(fill = factor(TierID))) + geom_sf(alpha = 0.1) +
#   coord_sf(datum = 2056) +
#   facet_wrap(~tiercollar) +
#   theme(legend.position = "none")
#
#
# tmap_mode("view") +
#   tm_shape(mcp) +
#   tm_fill("TierName", alpha = 0.5) +
#   tm_borders(col = "red", lwd = 1) +
#   tm_layout(legend.bg.color = "white")


# time lags ####

# replace wildboar_raw by wildboar_sf for spatial information
wildboar_lags <- wildboar_sf %>%
  group_by(TierID) %>%
  mutate(timelag = as.integer(difftime(lead(DatetimeUTC), DatetimeUTC), units = "secs"))

# round lags on -2 digits
wildboar_lags$timelag_rounded <- round(wildboar_lags$timelag, -2)

# build categories with rounded lags
wildboar_lag_cat <- wildboar_lags %>%
  st_drop_geometry() %>%
  group_by(timelag_rounded) %>%
  summarise(count = n())
wildboar_lag_cat

# used below
# compares count of timelag_rounded
hist_lag_cat <- ggplot(wildboar_lag_cat)
hist_lag_cat + geom_col(aes(x = timelag_rounded, y = count)) +
  coord_cartesian(ylim=c(0,200000), xlim=c(0,5000)) +
  labs(x = "rounded timelag [seconds]",
     y = "number of counts", 
     title = "Distribution of timelag between to data points",
     subtitle = "a clear majority is sampled with a timelag of 900 seconds") +   theme_bw() +
  theme(panel.border = element_blank())

# viualise change in lag over time ####

# takes a while for plotting..
# wildboar_lags %>%
#   filter(timelag < 30000 & timelag > 0) %>%
#   ggplot(., aes(DatetimeUTC, timelag, col = TierName)) +
#   geom_point() +
#   geom_line(size = 0.1)

# DELETE: calculating steplength ####

# wildboar_lags$steplength <- wildboar_raw %>%
#   {
#     (.$E - lead(.$E))^2 + (.$N - lead(.$N))^2
#   } %>%
#   sqrt()

# calculating speed based on timelag (t) in secs and steplength (s) in meter ####

# wildboar_lags$speed <- wildboar_lags %>% {
#   .$steplength / .$timelag
# }


# sample code for different intervals (to be discussed)
# wildboar_3 <- wildboar_3 %>%
#   mutate(timelag = as.integer(difftime(lead(DatetimeUTC), DatetimeUTC), units = "secs"))
#
# wildboar_3$steplength <- wildboar_3 %>%
#   {
#     (.$E - lead(.$E))^2 + (.$N - lead(.$N))^2
#   } %>%
#   sqrt()
#
# wildboar_3$speed <- wildboar_3 %>% {
#   .$steplength / .$timelag
# }

# preprocessing ####

# assign convenience variables for step 6
wildboar_lags <- wildboar_lags %>%
  # add wallow and nest criterias according to literature
  # enable line below if you want to filter all NAs in Frucht
  # filter(!is.na(Frucht)) %>%
  mutate(
    wallow_month = if_else(month > 3 & month < 10, TRUE, FALSE),
    wallow_day = case_when(
      day == "Abenddaemmerung" ~ FALSE,
      day == "Morgendaemmerung" ~ TRUE,
      day == "Nacht" ~ FALSE,
      day == "1Nachtviertel" ~ FALSE,
      day == "2Nachtviertel" ~ FALSE,
      day == "3Nachtviertel" ~ FALSE,
      day == "4Nachtviertel" ~ FALSE,
      day == "Tag" ~ TRUE,
      TRUE ~ NA # Default case
    ),
    wallow_area = case_when(
      Frucht == "Feuchtgebiet" ~ TRUE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ FALSE,
      Frucht == "Gerste" ~ FALSE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ FALSE,
      Frucht == "Raps" ~ FALSE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ FALSE,
      Frucht == "Roggen" ~ FALSE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    ),
    nest_day = case_when(
      day == "Abenddaemmerung" ~ FALSE,
      day == "Morgendaemmerung" ~ FALSE,
      day == "Nacht" ~ FALSE,
      day == "1Nachtviertel" ~ FALSE,
      day == "2Nachtviertel" ~ FALSE,
      day == "3Nachtviertel" ~ FALSE,
      day == "4Nachtviertel" ~ FALSE,
      day == "Tag" ~ TRUE,
      TRUE ~ NA # Default case
    ),
    nest_summer_mon = if_else(month >= 5 & month <= 10, TRUE, FALSE),
    nest_winter_mon = if_else(month >= 5 & month <= 10, FALSE, TRUE),
    nest_summer_area = case_when(
      Frucht == "Feuchtgebiet" ~ FALSE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ TRUE,
      Frucht == "Gerste" ~ TRUE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ TRUE,
      Frucht == "Raps" ~ TRUE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ TRUE,
      Frucht == "Roggen" ~ TRUE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    ),
    nest_winter_area = case_when(
      Frucht == "Feuchtgebiet" ~ TRUE,
      Frucht == "Wald" ~ TRUE,
      Frucht == "Weizen" ~ FALSE,
      Frucht == "Gerste" ~ FALSE,
      Frucht == "Zwiebeln" ~ FALSE,
      Frucht == "Bohnen" ~ FALSE,
      Frucht == "Kartoffeln" ~ FALSE,
      Frucht == "Rueben" ~ FALSE,
      Frucht == "Chinaschilf" ~ FALSE,
      Frucht == "Mangold" ~ FALSE,
      Frucht == "Wiese" ~ FALSE,
      Frucht == "Kohlrabi" ~ FALSE,
      Frucht == "Weide" ~ FALSE,
      Frucht == "Lupinen" ~ FALSE,
      Frucht == "Flugplatz" ~ FALSE,
      Frucht == "Mais" ~ FALSE,
      Frucht == "Raps" ~ FALSE,
      Frucht == "Karotten" ~ FALSE,
      Frucht == "Acker" ~ FALSE,
      Frucht == "Sonnenblumen" ~ FALSE,
      Frucht == "Erbsen" ~ FALSE,
      Frucht == "Kohl" ~ FALSE,
      Frucht == "Hafer" ~ FALSE,
      Frucht == "Roggen" ~ FALSE,
      Frucht == "Salat" ~ FALSE,
      Frucht == "Rhabarber" ~ FALSE,
      Frucht == "Sellerie" ~ FALSE,
      Frucht == "Brache" ~ FALSE,
      Frucht == "Spargel" ~ FALSE,
      Frucht == "Obstplantage" ~ FALSE,
      Frucht == "Fenchel" ~ FALSE,
      Frucht == "Gemuese" ~ FALSE,
      Frucht == "Gewaechshaus" ~ FALSE,
      Frucht == "Zuchetti" ~ FALSE,
      Frucht == "Zucchetti" ~ FALSE,
      Frucht == "Flachs" ~ FALSE,
      Frucht == "Kuerbis" ~ FALSE,
      TRUE ~ NA # Default case
    )
  )

# This checks a certain variable for NAs
# na_check <- wildboar_lags %>%
#   filter(is.na(wallow_area))

wildboar_lags <- calc_movement_param(wildboar_lags)
wildboar_lags <- wildboar_lags %>%
  # run segment-based analysis with rle_id. copied from cma_week 3
  # choose between: own threshold (mov_static) or from cma_week 3 (cma_static)
  mutate(segment_id = rle_id(mov_static)) %>%
  # select only rows with an certain timelag
  # if no filter is applied, sequencing creates misleading results
  # fraglich, ob der filter hier angewendet werden soll oder nach Sample data
  filter(timelag_rounded == 900)


summary(as.factor(wildboar_lags$mov_status))

mov_status <- data.frame(summary(as.factor(wildboar_lags$mov_status))) %>% 
  rename(count = 1) %>% 
  slice(-3) %>% 
  rownames_to_column(var = "status") %>% 
  mutate(prop = count/sum(count) * 100,
         prop = round(prop, 1)) %>% 
  arrange(desc(status)) %>%
  mutate(lab.ypos = cumsum(prop) - 0.5 * prop)

pie <- ggplot(mov_status, aes(x = "", y = prop, fill = status)) +
  geom_bar(width = 1, stat = "identity", color = "white") +
  coord_polar("y", start = 0) +
  geom_text(aes(y = lab.ypos, label = prop), color = "white") +
  scale_fill_discrete(name = "Status", labels = c("Resting", "Moving")) +
  theme_void()

pie

# cross-scale movement analysis ####
seq3 <- seq(from = 1, to = nrow(wildboar_raw), by = 3)
seq6 <- seq(from = 1, to = nrow(wildboar_raw), by = 6)
seq9 <- seq(from = 1, to = nrow(wildboar_raw), by = 9)
# Mein Vorschlag: unsere Auswertung aller Daten basiert auf wildboar_lags
# wildboar_3 <- wildboar_lags %>% slice(seq3)
# wildboar_6 <- wildboar_lags %>% slice(seq6)
# wildboar_9 <- wildboar_lags %>% slice(seq9)

# Sample data -------------------------------------------------------------

# step0 : select three different wildboars for a duration of two weeks ####
# Kritisch: hier werden samples aus wildboar_sf kreiert. so gehen viele
# convenience variablen verloren. Zudem ist es fehleranfälliger. Überdenken.

# create a sample of caroline
caro <- wildboar_sf %>%
  filter(
    year == 2015,
    month == 5,
    TierName == "Caroline"
  )

# create a sample of Frida
frida <- wildboar_sf %>%
  filter(
    year == 2016,
    month == 5,
    TierName == "Frida"
  )

# create a sample of Ueli
ueli <- wildboar_sf %>%
  filter(
    year == 2016,
    month == 5,
    TierName == "Ueli"
  )

# step 1: sequence data ####
# for sample data
caro_seq3 <- seq(from = 1, to = nrow(caro), by = 3)
caro_seq6 <- seq(from = 1, to = nrow(caro), by = 6)
frida_seq3 <- seq(from = 1, to = nrow(frida), by = 3)
frida_seq6 <- seq(from = 1, to = nrow(frida), by = 6)
ueli_seq3 <- seq(from = 1, to = nrow(ueli), by = 3)
ueli_seq6 <- seq(from = 1, to = nrow(ueli), by = 6)
caro_3 <- caro %>% slice(caro_seq3)
caro_6 <- caro %>% slice(caro_seq6)
frida_3 <- frida %>% slice(frida_seq3)
frida_6 <- frida %>% slice(frida_seq6)
ueli_3 <- ueli %>% slice(ueli_seq3)
ueli_6 <- ueli %>% slice(ueli_seq6)


# step 2: calculate speed, steplength and timelag for segmented da ####

# for sample data, for wildboar_lags its already done
caro <- calc_movement_param(caro)
caro_3 <- calc_movement_param(caro_3)
caro_6 <- calc_movement_param(caro_6)
frida <- calc_movement_param(frida)
frida_3 <- calc_movement_param(frida_3)
frida_6 <- calc_movement_param(frida_6)
ueli <- calc_movement_param(ueli)
ueli_3 <- calc_movement_param(ueli_3)
ueli_6 <- calc_movement_param(ueli_6)



# step 3: plot histogram and movement trajectories ------------------------

# plot histogram of stepmean
stepmean_ueli <- ggplot(ueli_6, aes(x = stepmean, fill = mov_status))
stepmean_ueli + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(x = "Mean steplength [meter]",
   y = "Number of counts", 
   title = "Mean steplength of wildboar Ueli",
   subtitle = "Sample dataset from May 2016 (segment_trigger = 40)")

stepmean_caro <- ggplot(caro_6, aes(x = stepmean, fill = mov_status))
stepmean_caro + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(x = "Mean steplength [meter]",
   y = "Number of counts", 
   title = "Mean steplength of wildboar Caroline",
   subtitle = "Sample dataset from May 2015 (segment_trigger = 40)")

stepmean_frida <- ggplot(frida_6, aes(x = stepmean, fill = mov_status))
stepmean_frida + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(x = "Mean steplength [meter]",
   y = "Number of counts", 
   title = "Mean steplength of wildboar Frida",
   subtitle = "Sample dataset from May 2016 (segment_trigger = 40)")


# step 4 to 6: assign movement status and apply criterias -----------------


# for all data

wildboar_lags <- wildboar_lags %>%
  group_by(segment_id) %>%
  mutate(segment_dur = n()) %>%
  filter(row_number(segment_id) == 1) %>% # keep only the first data point per segment
  ungroup() %>%
  mutate(wallow_dur = if_else(segment_dur <= 3, TRUE, FALSE)) %>%
  filter(mov_status == "resting") %>%
  mutate(
    wallow = if_else(wallow_month & wallow_day & wallow_area & wallow_dur,
      TRUE, FALSE
    ),
    nest = if_else((nest_summer_mon & nest_day & nest_summer_area & segment_dur > 3) |
      (nest_winter_mon & nest_day & nest_winter_area & segment_dur > 3),
    TRUE, FALSE
    ),
    conflict = if_else(nest & wallow, TRUE, FALSE),
    site_type = as.factor(case_when(
      conflict == TRUE ~ "both",
      nest == TRUE ~ "nest",
      wallow == TRUE ~ "wallow",
      !wallow & !nest == TRUE ~ "none",
      TRUE ~ "NA" # Default case
    ))
  )
  

# check the dataset (number of wallows, nests, NAs etc)

summary(wildboar_lags)

# create pie chart

site_type <- data.frame(summary(wildboar_lags$site_type)) %>% 
  rename(count = 1) %>% 
  rownames_to_column(var = "type") %>% 
  mutate(prop = count/sum(count) * 100,
         prop = round(prop, 1)) %>% 
  arrange(desc(type)) %>%
  mutate(lab.ypos = cumsum(prop) - 0.5 * prop)

pie <- ggplot(site_type, aes(x = "", y = prop, fill = type)) +
  geom_bar(width = 1, stat = "identity", color = "white") +
  coord_polar("y", start = 0) +
  geom_text(aes(y = lab.ypos, label = prop), color = "white") +
  scale_fill_discrete(name = "Type", labels = c("NA", "Nest", "None", "Wallow")) +
  theme_void()

pie


# plot sample data -------------------------------------------------------


# generate new samples from wildboar_lags data

ueli_filter <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "wallow" | site_type == "nest",
    TierName == "Ueli"
  ) %>% 
  mutate(site_type = droplevels(site_type))

frida_filter <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "wallow" | site_type == "nest",
    TierName == "Frida"
  ) %>% 
  mutate(site_type = droplevels(site_type))

caro_filter <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "wallow" | site_type == "nest",
    TierName == "Caroline"
  ) %>% 
  mutate(site_type = droplevels(site_type))

wallows_sample <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "wallow", 
    TierName == "Caroline" | TierName == "Ueli" | TierName == "Frida"
  ) %>% 
  mutate(site_type = droplevels(site_type))

nests_sample <- wildboar_lags %>%
  filter(
    year == 2016,
    # month == 5,
    site_type == "nest", 
    TierName == "Caroline" | TierName == "Ueli" | TierName == "Frida"
  ) %>% 
  mutate(site_type = droplevels(site_type))



# frida_filter <- wildboar_lags %>%
#   filter(
#     year == 2016,
#     # month == 5,
#     TierName == "Frida",
#     site_type == "nest"
#   )
# 
# caro_filter <- wildboar_lags %>%
#   filter(
#     year == 2016,
#     # month == 5,
#     TierName == "Caroline",
#     # site_type == "nest"
#   )

# Plot site_type
# alter site_type to explore (nest, wallow, both, none and NA)
# alter data to explore different boars

# ggplot(data = ueli_filter, mapping = aes(E, N, colour = segment_id)) +
#   # geom_path() +
#   geom_point() +
#   coord_equal() +
#   labs(title = "Moving segements coloured by segment ID") +
#   theme_classic() +
#   # RStudio crashes if legend.position "bottom" is chosen
#   theme(legend.position = "none")

# Polt interactive map with sample animals ####

# one layer per animal

# tmaptools::palette_explorer()

oranges <- tmaptools::get_brewer_pal("Oranges", n = 3, contrast = c(0.1, 0.9))
purples <- tmaptools::get_brewer_pal("Purples", n = 3, contrast = c(0.1, 0.9))

viridis <- viridisLite::viridis(3, begin = 0.23, end = 0.78)
magma   <- viridisLite::magma  (3, begin = 0.23, end = 0.78)

dark2 <- tmaptools::get_brewer_pal("Dark2", n = 6)
dark_n <- dark2[1:3]
dark_w <- dark2[4:6]


tm_animals <- 
  tmap_mode("view") +
  tm_shape(ueli_filter) +
  tm_symbols(col = "site_type", size = "segment_dur", alpha = 0.5, title.col = "Ueli", 
             palette = c("orange", "purple"), size.lim = c(1, 10)) +
  tm_shape(frida_filter) +
  tm_symbols(col = "site_type", size = "segment_dur", alpha = 0.5, title.col = "Frida", 
             palette = c("orange", "purple"), size.lim = c(1, 10)) +
    tm_shape(caro_filter) +
  tm_symbols(col = "site_type", size = "segment_dur", alpha = 0.5, title.col = "Caroline", 
             palette = c("orange", "purple"), size.lim = c(1, 10))

tm_animals

# one layer per field type (nests and wallos only)

tm_sample <- 
  tmap_mode("view") +
  tm_shape(nests_sample) +
  tm_symbols(col = "TierName", size = "segment_dur", alpha = 0.5, title.col = "Nests", 
             palette = magma, size.lim = c(1, 10)) +
  tm_shape(wallows_sample) +
  tm_symbols(col = "TierName", size = "segment_dur", alpha = 0.5, title.col = "Wallows", 
             palette = viridis, size.lim = c(1, 10))

tm_sample



# unused plots ------------------------------------------------------------


# caro %>%
#   ggplot(aes(E, N)) +
#   geom_path(alpha = 0.5) +
#   geom_point(alpha = 0.5) +
#   theme_bw() +
#   theme(panel.border = element_blank())
#
# caro_3 %>%
#   ggplot(aes(E, N)) +
#   geom_path(alpha = 0.5) +
#   geom_point(alpha = 0.5) +
#   theme_bw() +
#   theme(panel.border = element_blank())
#
# frida %>%
#   ggplot(aes(E, N)) +
#   geom_path(alpha = 0.5) +
#   geom_point(alpha = 0.5) +
#   theme_bw() +
#   theme(panel.border = element_blank())
#
# frida_3 %>%
#   ggplot(aes(E, N)) +
#   geom_path(alpha = 0.5) +
#   geom_point(alpha = 0.5) +
#   theme_bw() +
#   theme(panel.border = element_blank())
#
# ueli %>%
#   ggplot(aes(E, N)) +
#   geom_path(alpha = 0.5) +
#   geom_point(alpha = 0.5) +
#   theme_bw() +
#   theme(panel.border = element_blank())
#
# ueli_3 %>%
#   ggplot(aes(E, N)) +
#   geom_path(alpha = 0.5) +
#   geom_point(alpha = 0.5) +
#   theme_bw() +
#   theme(panel.border = element_blank())
#
# mcp_caro <- caro %>%
#   group_by(TierID, TierName, CollarID) %>%
#   summarise() %>%
#   st_convex_hull()
#
# plot convex hull
#
# tmap_mode("view") +
#   tm_shape(mcp_caro) +
#   tm_fill("TierName", alpha = 0.5) +
#   tm_borders(col = "red", lwd = 1) +
#   tm_layout(legend.bg.color = "white")



# mcp_caro <- caro_filter %>%
#   group_by(site_type, segment_id) %>%
#   summarise() %>%
#   st_convex_hull()
#
# tmap_mode("view") +
#   tm_shape(mcp_caro) +
#   tm_fill("segment_id", alpha = 0.5) +
#   tm_borders(col = "red", lwd = 1) +
#   tm_layout(legend.bg.color = "white")

# step 7 to 8: rasterize data ----------------------------------------------------------

# Erstellen eines raster-templates mit Aufloesung 30m (Analog zu steplenth threshold)
raster_100 <- raster(extent(wildboar_lags), resolution = 100, crs = 2056)
raster_30 <- raster(extent(wildboar_lags), resolution = 30, crs = 2056)

# resting filtern, jeweils ersten datenpunk pro segment id 

resting <- wildboar_lags %>% 
  group_by(segment_id) %>% 
  filter(row_number(segment_id) == 1)

# Wallows und Nests filtern fuer separate Layers, jeweils ersten Datenpunk pro segment id
wallows <- wildboar_lags %>%
  filter(wallow == "TRUE") %>% 
  group_by(segment_id) %>% 
  filter(row_number(segment_id) == 1)

nests <- wildboar_lags %>%
  filter(nest == "TRUE") %>% 
  group_by(segment_id) %>% 
  filter(row_number(segment_id) == 1)


# rasterize data

# Rastern der layer

resting_raster_100 <- raster::rasterize(resting, raster_100, field = 1, fun = "count")
wallows_raster_100 <- raster::rasterize(wallows, raster_100, field = 1, fun = "count")
nests_raster_100 <- raster::rasterize(nests, raster_100, field = 1, fun = "count")

resting_raster_30 <- raster::rasterize(resting, raster_30, field = 1, fun = "count")
wallows_raster_30 <- raster::rasterize(wallows, raster_30, field = 1, fun = "count")
nests_raster_30 <- raster::rasterize(nests, raster_30, field = 1, fun = "count")

# plots

greens <- tmaptools::get_brewer_pal("Greens", n = 6, contrast = c(0.3, 0.9))
oranges <- tmaptools::get_brewer_pal("Oranges", n = 5, contrast = c(0.3, 0.9))
purples <- tmaptools::get_brewer_pal("Purples", n = 5, contrast = c(0.3, 0.9))

# resolution: 100 m

tm_r_100 <- 
  tmap_mode("view") +
  tm_shape(resting_raster_100) +
  tm_raster(palette = greens, title = "Resting sites", alpha = 1)
  
tm_r_100

tm_nw_100 <-
  tmap_mode("view") +
  tm_shape(nests_raster_100) +
  tm_raster(palette = oranges, title = "Nests", alpha = 1) +
  tm_shape(wallows_raster_100) +
  tm_raster(palette = purples, title = "Wallows", alpha = 1) +
  tm_view(control.position = c("right", "top"))

tm_nw_100

# resolution: 30 m

tm_r_30 <- 
  tmap_mode("view") +
  tm_shape(resting_raster_30) +
  tm_raster(palette = greens, title = "Resting sites", alpha = 1)

tm_r_30

tm_nw_30 <-
  tmap_mode("view") +
  tm_shape(nests_raster_30) +
  tm_raster(palette = oranges, title = "Nests", alpha = 1) +
  tm_shape(wallows_raster_30) +
  tm_raster(palette = purples, title = "Wallows", alpha = 1) +
  tm_view(control.position = c("right", "top"))

tm_nw_30


# layer landnutzung: nicht sinnvoll, da unuebersichtlich

# tm +
# tm_shape(feldnutzung) +
# tm_polygon(col = "Frucht")

# leaflet plotten

# layer controls funktionieren nicht richtig

# tm %>%
#   tmap_leaflet() %>%
#   addLayersControl(
#     overlayGroups = c("Nests", "Wallows"),
#     options = layersControlOptions(collapsed = FALSE)
#   )
#

```

# Abstract

Tobias

# Research Questions

(yves) Our research is based on data from the ZHAW research project "Prevention of Wild Boar Damage in Agriculture"[@suter2018]. With this dataset as a basis, we want to answer the following research questions:

-   How can resting sites be modelled based on spatiotemporal movement data?

-   Can locations frequently visited by wild boar be determined efficiently and effectively in the provided research data?

-   Can these regular resting places be clearly defined as nests or wallows?

# Material and Methods

## Data

(yves) The provided data contains spatio-temporal datasets of 39 wildboars which were equipped with the GPS collar VERTEX PLUS [@vectronicaerospace2021]. Some wildboars were equipped multiple times which results in 46 unique datasets. The data was taken between 2014-05-28 and 2016-10-18 around the conservation zone Fanel which belongs to the cantons Bern and Neuenburg. The sampling regime varies widely in duration and interval. The vast majority of the recorded wild boar data has a timelag of 900 seconds between two points.

```{r histogram timelag, message=TRUE, warning=FALSE}
# compares count of timelag_rounded
hist_lag_cat <- ggplot(wildboar_lag_cat)
hist_lag_cat + geom_col(aes(x = timelag_rounded, y = count)) +
  coord_cartesian(ylim=c(0,200000), xlim=c(0,5000)) +
  labs(x = "rounded timelag [seconds]",
     y = "number of counts", 
     title = "Distribution of timelag between to data points",
     subtitle = "a clear majority is sampled with a timelag of 900 seconds") + 
  theme_bw() +
  theme(panel.border = element_blank())
```

Furthermore we added spatial information about the vegetation to the spatio-temporal wild boar data. This data was provided by a survey which classified the investigated area in forests, wetlands, settlement and agriculture. If a lot of land was used for agriculture, information about the planted crop is also given. In total the survey evaluated 5154 lots of land, covering an area of 120 km\^2. The evaluated area consists of 63 % agriculture, 22 % forest, 9 % settlement and 6 % wetlands [@suter2010].

## Analytical Concepts

### Calculation of Movement Parameter

In a prelimary phase we enriched the given data with important parameter for *Computational Movement Analysis*. For every data point we calculated *speed*, *steplength* and *timelag* to the next point.

Another movement parameter we added for our analysis is *stepmean*. It calculates the mean distance within a moving window of six data points. This variable allowed us to apply segmentation on our wild boar data and define stops and moves. In our work we call it *movement status* (Variable *mov_status* with a two factors: "resting" or "moving").

Since wild boars usually rest at nests and wallows the parameter movement status builds the basement for further analysis. A clear distinction between *resting* and *moving* was done by the introduction of the variable *segment_trigger*. The apropriate level of this threshold was evaluated in a critical manner. Sample data sets from three different wild boar movements were generated and evaluated in a histogram. With a binwidth of 5, we were able to see a clear decline in the first bins of stepmean. This lead to our interpretation that wild boars rest on the left side of the histogram and move on the right side.

```{r stepmean_threshold}
stepmean_ueli <- ggplot(ueli_6, aes(x = stepmean, fill = mov_status))
stepmean_ueli + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(x = "Mean steplength [meter]",
   y = "Number of counts", 
   title = "Mean steplength of wildboar Ueli",
   subtitle = "Sample dataset from May 2016 (segment_trigger = 40)")

stepmean_caro <- ggplot(caro_6, aes(x = stepmean, fill = mov_status))
stepmean_caro + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(x = "Mean steplength [meter]",
   y = "Number of counts", 
   title = "Mean steplength of wildboar Caroline",
   subtitle = "Sample dataset from May 2015 (segment_trigger = 40)")

stepmean_frida <- ggplot(frida_6, aes(x = stepmean, fill = mov_status))
stepmean_frida + geom_histogram(binwidth = 5 ) +
  scale_x_continuous(limits = c(0, 500)) +
  geom_vline(xintercept = 0, lty = 2, alpha = 0.5) +
  theme_bw() +
  theme(panel.border = element_blank()) +
  labs(x = "Mean steplength [meter]",
   y = "Number of counts", 
   title = "Mean steplength of wildboar Frida",
   subtitle = "Sample dataset from May 2016 (segment_trigger = 40)")
```

Setting the threshold seems reasonable at the point where stepmean flattens in a distinct manner (see histograms). In our samples this threshold can be anywhere between 30 to 50 meter.

The mentioned movement parameter were implemented in the function *calc_movement_param*.

```{r calc_movement_param, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# functions ---------------------------------------------------------------

calc_movement_param <- function(boar_dt) {
  boar_dt <- boar_dt %>%
    mutate(
      timelag = as.integer(difftime(lead(DatetimeUTC), DatetimeUTC, units = "secs")),
      steplength = sqrt(((E - lead(E, 1))^2 + (N - lead(N, 1))^2)),
      speed = steplength / timelag,
      nMinus3 = sqrt((lag(E, 3) - E)^2 + (lag(N, 3) - N)^2),
      nMinus2 = sqrt((lag(E, 2) - E)^2 + (lag(N, 2) - N)^2),
      nMinus1 = sqrt((lag(E, 1) - E)^2 + (lag(N, 1) - N)^2),
      nPlus1 = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2),
      nPlus2 = sqrt((E - lead(E, 2))^2 + (N - lead(N, 2))^2),
      nPlus3 = sqrt((E - lead(E, 3))^2 + (N - lead(N, 3))^2)
    ) %>%
    rowwise() %>%
    mutate(
      stepmean = mean(c(nMinus3, nMinus2, nMinus1, nPlus1, nPlus2, nPlus3)),
    ) %>%
    ungroup() %>%
    mutate(
      mov_static = if_else(stepmean < segment_trigger, TRUE, FALSE),
      mov_status = if_else(stepmean < segment_trigger, "resting", "moving"),
      cma_static = stepmean < mean(stepmean, na.rm = TRUE)
    )
  boar_dt
}
```

### Segementation

The generated stops and moves will then be annotated with a status and joined with land use type to provide further context. Finally, for each resting trajectory a convex hull will be calculated to visualize the results.

### Wild Boar Behavior

Wild boars share a common movement pattern when spending time at wallows and nests: they stick to a location for a certain while and do not undertake wide distances during this time. Distinguishing this behavior from others builds the basement of our analytical concept. Wild boar biologists differentiate between the following wild boar behaviour [@keuling2009]:

-   Feeding
-   protective behavior
-   aggressive behavior
-   comfort behavior
-   other behavior (sleeping, resting, fleeing, strolling)

According to literature wild boar show some behavioral patterns at nests and wallows:

-   **Nests:** Multiple wild boars gather in close distance and stay there for an undefined while [@keuling2009]. Since wild boars are nocturnal animals, they preferably rest in covered areas like forests or wetlands with high reeds. During summertime agricultural Fields with high crops like barley, rapeseed or wheat can also provide a suitable nesting habitat. Surveys in this area showed that wild boars normally rest between 8:00 and 17:00 and revisit its nests up to eight times [@suter2010].

-   **Wallows:** Wild boars use wallows for hygiene purposes [@keuling2009]. In a wallow the boar is able to regulate their body temperature since wild boars cannot sweat. This leads to fact that wallowing happens mainly during summer season and are not observed before April [@fernández-llario2005]. On a daily view, wild boars wallow during nighttime and early morning [@meynhardt1990]. In comparison to the behavior at nests, wild boars spend less time at wallows since it is clearly a comfort behavior and does not serve a basic need[@keuling2009].

### Adding Context

Stepmean, Segmentation,

Anhand von Literatur Kriterien festgelegt für Nester und Suhlen

Sampling Regime (nur 15 Minuten Intervalle)

## R Concecpts

Tobias

The analysis, visualisation and documentation was conducted in the open-source software R, version 4.0.5 [@rcoreteam2021]. The handling of spatiotemporal data was managed with the packages sf [@pebesma2018], terra [@hijmans2021] and raster [@hijmans2020]. The graphical representations were created with ggplot2 [@wickham2016] as part of tidyverse [@wickham2019], which was also used for general data wrangling, alongside forcats [@wickham2021] to handle factor levels and janitor [@firke2021] for clean and consistent naming. Maps were generated using tmap [@tennekes2018] and leaflet [@cheng2021].

Umsetzungskonzepte in R

# Results / Products

Tobias

Boxplot mit Stepmean, Exemplarische Plots nach Tieren, Raster graphs, Anteile Site Types & Moving / Resting,

Text

# Discussion

Yves

Warum so viele none und auch both? Evtl. Tabelle der Anteile hier bringen.

Forschungsfragen beantworten

Schwellenwerte und Rastergrössen diskutieren

## Risk analysis / Problems

Keine Validierung möglich, Literaturangaben zur Differenzierung nach N/W unzureichend. Intervalle der Messungen diskutieren, nur 15 Min berücksichtigt, dadurch Datenvelrust

Text

# References

Tobias

::: {#refs}
:::

# Annex

R Script

```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE, class.source = "fold-show"}

```
